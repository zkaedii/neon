<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON TOKYO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; min-height: 100vh; font-family: 'Orbitron', sans-serif; overflow: hidden; }
        .container { width: 100vw; height: 100vh; display: flex; flex-direction: column; }
        .led-frame { flex: 1; background: #050508; position: relative; overflow: hidden; }
        #sceneCanvas, #ledCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #sceneCanvas { opacity: 0; }

        .controls { display: flex; gap: 10px; padding: 12px; background: #0a0a0f; border-top: 1px solid #222; flex-wrap: wrap; align-items: center; overflow-x: auto; max-height: 200px; overflow-y: auto; }
        .btn { font-family: 'Orbitron', sans-serif; font-size: 11px; padding: 10px 16px; background: #111; border: 1px solid #0ff; color: #0ff; border-radius: 4px; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.05em; white-space: nowrap; flex-shrink: 0; }
        .btn:hover { background: rgba(0,255,255,0.2); box-shadow: 0 0 10px rgba(0,255,255,0.3); }
        .btn.active { background: #0ff; color: #000; box-shadow: 0 0 15px rgba(0,255,255,0.5); }
        .btn.file-btn { position: relative; overflow: hidden; background: #1a0825; border-color: #f0f; color: #f0f; }
        .btn.file-btn:hover { background: rgba(255,0,255,0.2); box-shadow: 0 0 10px rgba(255,0,255,0.3); }
        .btn.file-btn input { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }

        .control-group { display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.03); padding: 6px 10px; border-radius: 4px; }
        .control-label { font-size: 8px; color: #666; letter-spacing: 0.1em; }
        .slider { -webkit-appearance: none; appearance: none; width: 70px; height: 3px; background: #333; border-radius: 2px; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #0ff; border-radius: 50%; cursor: pointer; }
        .slider-value { font-size: 10px; color: #0ff; min-width: 30px; }
        .mode-select { font-family: 'Orbitron', sans-serif; font-size: 9px; padding: 4px 8px; background: #111; border: 1px solid #0ff; color: #0ff; border-radius: 3px; cursor: pointer; outline: none; }
        .mode-select:hover { background: rgba(0, 255, 255, 0.1); }

        .freq-bars { display: flex; gap: 2px; align-items: flex-end; height: 30px; padding: 3px; background: rgba(0,0,0,0.5); border-radius: 3px; }
        .freq-bar { width: 6px; background: linear-gradient(to top, #0ff, #f0f); border-radius: 1px; transition: height 0.05s; }
        .status { font-size: 9px; color: #666; margin-left: auto; }
        .status.playing { color: #0f0; }
        .scene-title { font-size: 10px; color: #f0f; letter-spacing: 0.2em; }

        .audio-panel { position: fixed; right: 10px; top: 50%; transform: translateY(-50%); background: rgba(10, 10, 15, 0.95); border: 1px solid #0ff; border-radius: 8px; padding: 16px; width: 280px; max-height: 80vh; overflow-y: auto; display: none; z-index: 1000; }
        .audio-panel.active { display: block; }
        .panel-header { font-size: 11px; color: #0ff; margin-bottom: 12px; letter-spacing: 0.15em; text-align: center; border-bottom: 1px solid #0ff; padding-bottom: 8px; }
        .audio-section { margin-bottom: 16px; }
        .section-title { font-size: 9px; color: #f0f; letter-spacing: 0.1em; margin-bottom: 8px; }
        .audio-band-selector { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-bottom: 8px; }
        .band-btn { font-size: 8px; padding: 6px 4px; background: rgba(0, 255, 255, 0.1); border: 1px solid #0ff; color: #0ff; border-radius: 3px; cursor: pointer; transition: all 0.2s; }
        .band-btn.active { background: #0ff; color: #000; }
        .audio-target-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px; }
        .target-checkbox { display: flex; align-items: center; gap: 6px; font-size: 8px; color: #aaa; }
        .target-checkbox input[type="checkbox"] { accent-color: #0ff; }
        .sensitivity-slider { width: 100%; margin-top: 4px; }
        .close-panel { position: absolute; top: 8px; right: 8px; background: none; border: none; color: #f0f; font-size: 16px; cursor: pointer; padding: 4px; }
        .spectrum-viz { height: 60px; background: rgba(0, 0, 0, 0.5); border-radius: 4px; padding: 4px; display: flex; align-items: flex-end; gap: 2px; margin-top: 8px; }
        .spectrum-bar { flex: 1; background: linear-gradient(to top, #0ff, #f0f); border-radius: 1px; min-width: 2px; }
        .curve-selector { display: flex; gap: 4px; margin-top: 6px; }
        .curve-btn { flex: 1; font-size: 7px; padding: 4px; background: rgba(0, 255, 255, 0.1); border: 1px solid #0ff; color: #0ff; border-radius: 3px; cursor: pointer; }
        .curve-btn.active { background: #0ff; color: #000; }
        .image-preview { width: 60px; height: 60px; margin: 0 auto 12px; border: 2px solid #0ff; border-radius: 4px; object-fit: contain; background: rgba(0, 0, 0, 0.5); }

        .file-gallery { display: flex; gap: 8px; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px; flex-wrap: wrap; max-height: 120px; overflow-y: auto; margin-top: 8px; }
        .file-item { position: relative; width: 80px; height: 80px; border: 2px solid #0ff; border-radius: 4px; overflow: hidden; background: rgba(0, 0, 0, 0.5); cursor: pointer; transition: all 0.2s; }
        .file-item:hover { border-color: #f0f; box-shadow: 0 0 10px rgba(255, 0, 255, 0.5); transform: scale(1.05); }
        .file-item.audio { border-color: #39ff14; }
        .file-item.audio:hover { border-color: #0ff; }
        .file-item img { width: 100%; height: 100%; object-fit: cover; }
        .file-item .file-icon { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 32px; color: #0ff; }
        .file-item .remove-btn { position: absolute; top: 2px; right: 2px; background: rgba(255, 0, 0, 0.8); border: none; color: #fff; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; font-size: 12px; line-height: 1; display: none; }
        .file-item:hover .remove-btn { display: block; }
        .file-item .file-name { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.8); color: #fff; font-size: 8px; padding: 2px 4px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; }
        .file-item.loading { opacity: 0.6; }
        .file-item.loading::after { content: ''; position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; margin: -10px 0 0 -10px; border: 2px solid #0ff; border-top-color: transparent; border-radius: 50%; animation: spin 0.6s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .drop-zone { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.9); border: 3px dashed #0ff; display: none; align-items: center; justify-content: center; z-index: 10000; pointer-events: none; }
        .drop-zone.active { display: flex; pointer-events: all; }
        .drop-zone .drop-message { font-size: 24px; color: #0ff; text-align: center; text-shadow: 0 0 20px rgba(0, 255, 255, 0.8); }
        .drop-zone.audio-zone { border-color: #39ff14; }
        .drop-zone.audio-zone .drop-message { color: #39ff14; }

        .upload-progress { position: fixed; bottom: 20px; right: 20px; background: rgba(10, 10, 15, 0.95); border: 1px solid #0ff; border-radius: 8px; padding: 12px; min-width: 200px; max-width: 300px; z-index: 9999; display: none; }
        .upload-progress.active { display: block; }
        .upload-progress .progress-item { margin-bottom: 8px; font-size: 10px; color: #aaa; }
        .upload-progress .progress-item:last-child { margin-bottom: 0; }
        .upload-progress .progress-bar { width: 100%; height: 4px; background: #333; border-radius: 2px; margin-top: 4px; overflow: hidden; }
        .upload-progress .progress-fill { height: 100%; background: linear-gradient(90deg, #0ff, #f0f); transition: width 0.3s; }
    </style>
</head>
<body>
    <div class="container">
        <div class="led-frame">
            <canvas id="sceneCanvas"></canvas>
            <canvas id="ledCanvas"></canvas>
        </div>
        <div class="controls">
            <span class="scene-title">„Éç„Ç™„É≥Êù±‰∫¨</span>
            <button class="btn file-btn">üéµ LOAD MP3<input type="file" id="audioFile" accept="audio/*"></button>
            <button class="btn file-btn">üñºÔ∏è LOAD IMAGE<input type="file" id="imageFile" accept="image/*" multiple></button>
            <button class="btn" id="playBtn">‚ñ∂ PLAY</button>
            <button class="btn" id="clearImagesBtn" style="border-color: #ff6b00; color: #ff6b00;">‚úï CLEAR</button>
            <div class="file-gallery" id="fileGallery"></div>
            <button class="btn file-btn" style="border-color: #39ff14; color: #39ff14;">üíæ SAVE PRESET<input type="file" id="presetFile" accept=".json" style="display: none;"></button>
            <button class="btn" id="loadPresetBtn" style="border-color: #39ff14; color: #39ff14;">üìÇ LOAD</button>
            <button class="btn" id="fullscreenBtn" style="border-color: #ff00ff; color: #ff00ff;">‚õ∂ FULL</button>

            <div class="control-group"><span class="control-label">MODE</span><select class="mode-select" id="displayMode"><option value="floating">FLOAT</option><option value="fullscreen">FULL</option><option value="tiled">TILE</option></select></div>
            <div class="control-group"><span class="control-label">LAYER</span><select class="mode-select" id="imageLayer"><option value="front">FRONT</option><option value="back">BACK</option><option value="only">ONLY</option></select></div>
            <div class="control-group"><span class="control-label">MOVE</span><select class="mode-select" id="moveMode"><option value="float">FLOAT</option><option value="bounce">BOUNCE</option><option value="orbit">ORBIT</option><option value="wave">WAVE</option><option value="spin">SPIN</option><option value="pulse">PULSE</option></select></div>
            <div class="control-group"><span class="control-label">BLEND</span><select class="mode-select" id="blendMode"><option value="normal">NORM</option><option value="screen">SCRN</option><option value="multiply">MULT</option><option value="overlay">OVER</option></select></div>
            <div class="control-group"><span class="control-label">SIZE</span><input type="range" class="slider" id="imageSizeSlider" min="20" max="200" value="100"><span class="slider-value" id="imageSizeValue">100%</span></div>
            <div class="control-group"><span class="control-label">LED</span><input type="range" class="slider" id="pixelSlider" min="40" max="200" value="100"><span class="slider-value" id="pixelValue">100</span></div>
            <div class="control-group"><span class="control-label">REACT</span><input type="range" class="slider" id="reactSlider" min="0" max="100" value="80"><span class="slider-value" id="reactValue">80%</span></div>
            <div class="control-group"><span class="control-label">RAIN</span><input type="range" class="slider" id="rainSlider" min="0" max="100" value="70"><span class="slider-value" id="rainValue">70%</span></div>
            <div class="control-group"><span class="control-label">GLOW</span><input type="range" class="slider" id="glowSlider" min="0" max="100" value="60"><span class="slider-value" id="glowValue">60%</span></div>
            <div class="freq-bars" id="freqBars"></div>
            <span class="status" id="status">NO AUDIO ‚Ä¢ 0 IMAGES</span>
        </div>
    </div>

    <div class="drop-zone" id="dropZone">
        <div class="drop-message">DROP FILES HERE</div>
    </div>

    <div class="upload-progress" id="uploadProgress">
        <div class="progress-item">
            <span class="progress-name">Loading...</span>
            <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
        </div>
    </div>

    <div class="audio-panel" id="audioPanel">
        <button class="close-panel" id="closePanel">‚úï</button>
        <div class="panel-header">AUDIO MAPPING</div>
        <img class="image-preview" id="imagePreview" src="" alt="Selected">
        <div class="audio-section">
            <div class="section-title">FREQUENCY BAND</div>
            <div class="audio-band-selector">
                <button class="band-btn" data-band="sub_bass">SUB</button>
                <button class="band-btn active" data-band="bass">BASS</button>
                <button class="band-btn" data-band="low_mid">LOW-M</button>
                <button class="band-btn" data-band="mid">MID</button>
                <button class="band-btn" data-band="high_mid">HI-M</button>
                <button class="band-btn" data-band="high">HIGH</button>
                <button class="band-btn" data-band="ultra_high">ULTRA</button>
            </div>
            <div class="spectrum-viz" id="spectrumViz"></div>
        </div>
        <div class="audio-section">
            <div class="section-title">AUDIO TARGETS</div>
            <div class="audio-target-grid">
                <label class="target-checkbox"><input type="checkbox" id="targetScale" checked><span>SCALE</span></label>
                <label class="target-checkbox"><input type="checkbox" id="targetRotation"><span>ROTATION</span></label>
                <label class="target-checkbox"><input type="checkbox" id="targetX"><span>X-POS</span></label>
                <label class="target-checkbox"><input type="checkbox" id="targetY"><span>Y-POS</span></label>
                <label class="target-checkbox"><input type="checkbox" id="targetAlpha"><span>ALPHA</span></label>
                <label class="target-checkbox"><input type="checkbox" id="targetHue"><span>HUE</span></label>
            </div>
        </div>
        <div class="audio-section">
            <div class="section-title">SENSITIVITY: <span id="sensitivityValue">100%</span></div>
            <input type="range" class="slider sensitivity-slider" id="sensitivitySlider" min="0" max="200" value="100">
        </div>
        <div class="audio-section">
            <div class="section-title">RESPONSE CURVE</div>
            <div class="curve-selector">
                <button class="curve-btn active" data-curve="linear">LIN</button>
                <button class="curve-btn" data-curve="exponential">EXP</button>
                <button class="curve-btn" data-curve="sigmoid">SIG</button>
            </div>
        </div>
        <div class="audio-section">
            <div class="section-title">SMOOTHING: <span id="smoothingValue">0.7</span></div>
            <input type="range" class="slider sensitivity-slider" id="smoothingSlider" min="0" max="100" value="70">
        </div>
    </div>

<script>
"use strict";

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONFIGURATION & CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const CONFIG = {
  SCENE_WIDTH: 640,
  SCENE_HEIGHT: 360,
  PALETTE: {
    primary: "#00f5ff",
    secondary: "#ff00ff",
    accent: "#ff6b00",
    highlight: "#39ff14",
    neon: ["#00f5ff", "#ff00ff", "#ff6b00", "#39ff14", "#ff0055"],
  },
};

const BANDS = {
  sub_bass: { range: [0, 2], smoothed: 0 },
  bass: { range: [2, 8], smoothed: 0 },
  low_mid: { range: [8, 16], smoothed: 0 },
  mid: { range: [16, 32], smoothed: 0 },
  high_mid: { range: [32, 48], smoothed: 0 },
  high: { range: [48, 64], smoothed: 0 },
  ultra_high: { range: [64, 96], smoothed: 0 },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const state = {
  t: 0,
  isPlaying: false,
  beatDetected: false,
  lastBeatTime: 0,

  // Settings
  pixelSize: 100,
  reactivity: 0.8,
  rainIntensity: 0.7,
  glowAmount: 0.6,
  bloomIntensity: 0.8,
  chromaticAberration: 0.003,
  motionBlur: 0.3,
  fogDensity: 0.15,
  imageScale: 1.0,
  imageMoveMode: "float",
  imageBlendMode: "normal",
  imageDisplayMode: "floating",
  imageLayer: "front",

  // Selection/interaction
  selectedImage: null,
  draggedImage: null,
  isDragging: false,

  // Character control
  character: null,
  keys: {},
  characterSpeed: 2.5,
  characterVelocity: { x: 0, y: 0 },

  // World boundaries
  worldBounds: {
    minX: 0,
    maxX: CONFIG.SCENE_WIDTH,
    minY: 0,
    maxY: CONFIG.SCENE_HEIGHT,
  },

  // Beat-based spawning
  beatHistory: [],
  lastSpawnTime: 0,
  spawnCooldown: 100,

  // Audio
  bassAvg: 0,
  midAvg: 0,
  highAvg: 0,
  beatIntensity: 0,

  // File management
  loadedFiles: [],
  uploadQueue: [],
};

const entities = {
  buildings: [],
  people: [],
  cars: [],
  raindrops: [],
  splashes: [],
  steamParticles: [],
  sparks: [],
  images: [],
  spawnedObjects: [], // Beat-spawned objects
};

let audioCtx, analyser, audioElement;
let freqData = new Uint8Array(256);

// Canvas references
const sceneCanvas = document.getElementById("sceneCanvas");
const sceneCtx = sceneCanvas.getContext("2d");
const ledCanvas = document.getElementById("ledCanvas");
const ledCtx = ledCanvas.getContext("2d");

// Post-processing buffers
let postProcessCanvas, postProcessCtx;
let bloomCanvas, bloomCtx;
let previousFrameCanvas, previousFrameCtx;

// WebGL for LED rendering (performance boost)
let gl, glProgram, glBuffers, glTextures;
let useWebGL = true;

// Performance monitoring
const perf = {
  frameCount: 0,
  lastFPS: 60,
  lastTime: performance.now(),
  update() {
    this.frameCount++;
    const now = performance.now();
    if (now - this.lastTime >= 1000) {
      this.lastFPS = this.frameCount;
      this.frameCount = 0;
      this.lastTime = now;
    }
  },
};

// Object pools for particles
const pools = {
  raindrops: [],
  splashes: [],
  sparks: [],
  steam: [],
  get(type) {
    return this[type].pop() || null;
  },
  release(type, obj) {
    if (this[type].length < 1000) {
      this[type].push(obj);
    }
  },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UTILITIES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const utils = {
  drawRoundedRect(ctx, x, y, w, h, radius) {
    if (ctx.roundRect) {
      ctx.roundRect(x, y, w, h, radius);
    } else {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }
  },

  resizeCanvas() {
    const rect = ledCanvas.parentElement.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance

    // Enhanced LED canvas with better quality settings
    ledCanvas.width = rect.width * dpr;
    ledCanvas.height = rect.height * dpr;
    ledCanvas.style.width = rect.width + "px";
    ledCanvas.style.height = rect.height + "px";

    // Enhanced context settings for better rendering quality
    ledCtx.imageSmoothingEnabled = true;
    ledCtx.imageSmoothingQuality = "high";
    ledCtx.textRenderingOptimization = "optimizeQuality";
    ledCtx.scale(dpr, dpr);

    // Enhanced scene canvas with better quality
    sceneCanvas.width = CONFIG.SCENE_WIDTH;
    sceneCanvas.height = CONFIG.SCENE_HEIGHT;
    sceneCtx.imageSmoothingEnabled = true;
    sceneCtx.imageSmoothingQuality = "high";
    sceneCtx.textRenderingOptimization = "optimizeQuality";
    sceneCtx.willReadFrequently = false; // Optimize for write operations

    // Initialize post-processing buffers with enhanced settings
    if (!postProcessCanvas) {
      postProcessCanvas = document.createElement("canvas");
      postProcessCanvas.width = CONFIG.SCENE_WIDTH;
      postProcessCanvas.height = CONFIG.SCENE_HEIGHT;
      postProcessCtx = postProcessCanvas.getContext("2d", {
        alpha: true,
        willReadFrequently: true,
        desynchronized: false,
      });
      postProcessCtx.imageSmoothingEnabled = true;
      postProcessCtx.imageSmoothingQuality = "high";

      bloomCanvas = document.createElement("canvas");
      bloomCanvas.width = CONFIG.SCENE_WIDTH;
      bloomCanvas.height = CONFIG.SCENE_HEIGHT;
      bloomCtx = bloomCanvas.getContext("2d", {
        alpha: true,
        willReadFrequently: true,
      });
      bloomCtx.imageSmoothingEnabled = true;
      bloomCtx.imageSmoothingQuality = "high";

      previousFrameCanvas = document.createElement("canvas");
      previousFrameCanvas.width = CONFIG.SCENE_WIDTH;
      previousFrameCanvas.height = CONFIG.SCENE_HEIGHT;
      previousFrameCtx = previousFrameCanvas.getContext("2d", {
        alpha: true,
        willReadFrequently: false,
      });
      previousFrameCtx.imageSmoothingEnabled = true;
      previousFrameCtx.imageSmoothingQuality = "high";
    }
    drawRoundedRect(ctx, x, y, w, h, radius) {
        if (ctx.roundRect) {
            ctx.roundRect(x, y, w, h, radius);
        } else {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
            ctx.lineTo(x + radius, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
    },

    resizeCanvas() {
        const rect = ledCanvas.parentElement.getBoundingClientRect();
        const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance

        // Enhanced LED canvas with better quality settings
        ledCanvas.width = rect.width * dpr;
        ledCanvas.height = rect.height * dpr;
        ledCanvas.style.width = rect.width + 'px';
        ledCanvas.style.height = rect.height + 'px';

        // Enhanced context settings for better rendering quality
        ledCtx.imageSmoothingEnabled = true;
        ledCtx.imageSmoothingQuality = 'high';
        ledCtx.scale(dpr, dpr);

        // Enhanced scene canvas with better quality
        sceneCanvas.width = CONFIG.SCENE_WIDTH;
        sceneCanvas.height = CONFIG.SCENE_HEIGHT;
        sceneCtx.imageSmoothingEnabled = true;
        sceneCtx.imageSmoothingQuality = 'high';
        sceneCtx.willReadFrequently = false; // Optimize for write operations

        // Initialize post-processing buffers with enhanced settings
        if (!postProcessCanvas) {
            postProcessCanvas = document.createElement('canvas');
            postProcessCanvas.width = CONFIG.SCENE_WIDTH;
            postProcessCanvas.height = CONFIG.SCENE_HEIGHT;
            postProcessCtx = postProcessCanvas.getContext('2d', {
                alpha: true,
                willReadFrequently: true,
                desynchronized: false
            });
            postProcessCtx.imageSmoothingEnabled = true;
            postProcessCtx.imageSmoothingQuality = 'high';

            bloomCanvas = document.createElement('canvas');
            bloomCanvas.width = CONFIG.SCENE_WIDTH;
            bloomCanvas.height = CONFIG.SCENE_HEIGHT;
            bloomCtx = bloomCanvas.getContext('2d', {
                alpha: true,
                willReadFrequently: true
            });
            bloomCtx.imageSmoothingEnabled = true;
            bloomCtx.imageSmoothingQuality = 'high';

            previousFrameCanvas = document.createElement('canvas');
            previousFrameCanvas.width = CONFIG.SCENE_WIDTH;
            previousFrameCanvas.height = CONFIG.SCENE_HEIGHT;
            previousFrameCtx = previousFrameCanvas.getContext('2d', {
                alpha: true,
                willReadFrequently: false
            });
            previousFrameCtx.imageSmoothingEnabled = true;
            previousFrameCtx.imageSmoothingQuality = 'high';
        }

    // Initialize WebGL if available with enhanced settings
    if (useWebGL && !gl) {
      try {
        gl =
          ledCanvas.getContext("webgl2", {
            alpha: false,
            antialias: true,
            depth: false,
            stencil: false,
            preserveDrawingBuffer: false,
            powerPreference: "high-performance",
            failIfMajorPerformanceCaveat: false,
          }) ||
          ledCanvas.getContext("webgl", {
            alpha: false,
            antialias: true,
            depth: false,
            stencil: false,
            preserveDrawingBuffer: false,
            powerPreference: "high-performance",
            failIfMajorPerformanceCaveat: false,
          });
        if (gl) {
          // Enable WebGL extensions for better quality
          gl.getExtension("OES_texture_float");
          gl.getExtension("OES_texture_float_linear");
          gl.getExtension("EXT_texture_filter_anisotropic");
          this.initWebGL();
        }
      } catch (e) {
        console.warn("WebGL not available, falling back to 2D canvas");
        useWebGL = false;
      }
    }
  },

  initWebGL() {
    if (!gl) {
      return;
    }

    const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

    const fragmentShaderSource = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform float u_glow;
            uniform float u_reactivity;
            uniform sampler2D u_freq;
            varying vec2 v_texCoord;

            void main() {
                vec4 color = texture2D(u_texture, v_texCoord);
                float freq = texture2D(u_freq, vec2(v_texCoord.x, 0.0)).r;
                float boost = 1.0 + freq * u_reactivity * 0.6;
                color.rgb *= boost;
                color.rgb = min(color.rgb, vec3(1.0));

                if (u_glow > 0.0 && dot(color.rgb, vec3(0.299, 0.587, 0.114)) > 0.47) {
                    float glowSize = 0.4 * u_glow;
                    float dist = length(v_texCoord - vec2(0.5));
                    float glow = smoothstep(0.5, 0.5 + glowSize, dist);
                    color.rgb += color.rgb * (1.0 - glow) * 0.4;
                }

                gl_FragColor = color;
            }
        `;

    const vs = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
    const fs = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
    if (!vs || !fs) {
      return;
    }

    glProgram = gl.createProgram();
    gl.attachShader(glProgram, vs);
    gl.attachShader(glProgram, fs);
    gl.linkProgram(glProgram);

    if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
      console.warn("WebGL program link failed");
      useWebGL = false;
      return;
    }

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([-1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, 1, 1, 1, 0]),
      gl.STATIC_DRAW
    );

    glBuffers = { position: positionBuffer };

    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAX_FILTER, gl.LINEAR);
    glTextures = { scene: texture, freq: gl.createTexture() };
  },

  createShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader compile error:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  },

  weightedRandom(items) {
    const total = items.reduce((sum, item) => sum + item.weight, 0);
    let rand = Math.random() * total;
    for (const item of items) {
      rand -= item.weight;
      if (rand <= 0) {
        return item;
      }
    }
    return items[0];
  },

  updateStatus() {
    const statusEl = document.getElementById("status");
    const audioText = audioElement
      ? audioElement.src.split("/").pop().substring(0, 15)
      : "NO AUDIO";
    const imageText = `${entities.images.length} IMAGE${entities.images.length !== 1 ? "S" : ""}`;
    const fpsText = perf.lastFPS > 0 ? ` ‚Ä¢ ${perf.lastFPS} FPS` : "";
    const renderText = useWebGL ? " [WebGL]" : " [2D]";
    const characterText = state.character ? " ‚Ä¢ üéÆ WASD/ARROWS" : "";
    statusEl.textContent = `${audioText} ‚Ä¢ ${imageText}${characterText}${fpsText}${renderText}`;
  },

  savePreset() {
    const preset = {
      version: "2.0",
      timestamp: Date.now(),
      state: {
        pixelSize: state.pixelSize,
        reactivity: state.reactivity,
        rainIntensity: state.rainIntensity,
        glowAmount: state.glowAmount,
        imageScale: state.imageScale,
        imageMoveMode: state.imageMoveMode,
        imageBlendMode: state.imageBlendMode,
        imageDisplayMode: state.imageDisplayMode,
        imageLayer: state.imageLayer,
      },
      images: entities.images.map((img) => ({
        x: img.baseX,
        y: img.baseY,
        scale: img.scale,
        rotation: img.rotation,
        alpha: img.alpha,
        audioMapping: img.audioMapping,
        src: img.img.src,
      })),
    };

    const dataStr = JSON.stringify(preset, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `neon-tokyo-preset-${Date.now()}.json`;
    link.click();
    URL.revokeObjectURL(url);
  },

  loadPreset(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const preset = JSON.parse(e.target.result);

        // Handle new JSON schema format
        if (preset.canvas) {
          CONFIG.SCENE_WIDTH = preset.canvas.width || CONFIG.SCENE_WIDTH;
          CONFIG.SCENE_HEIGHT = preset.canvas.height || CONFIG.SCENE_HEIGHT;
          utils.resizeCanvas();
        }

        if (preset.color_palette) {
          if (preset.color_palette.primary) CONFIG.PALETTE.primary = preset.color_palette.primary;
          if (preset.color_palette.secondary) CONFIG.PALETTE.secondary = preset.color_palette.secondary;
          if (preset.color_palette.accent) CONFIG.PALETTE.accent = preset.color_palette.accent;
          if (preset.color_palette.highlight) CONFIG.PALETTE.highlight = preset.color_palette.highlight;
          if (preset.color_palette.neon) CONFIG.PALETTE.neon = preset.color_palette.neon;
        }

        if (preset.environment && preset.environment.sky && preset.environment.sky.rain) {
          state.rainIntensity = preset.environment.sky.rain.intensity || state.rainIntensity;
        }

        if (preset.lighting && preset.lighting.fog) {
          state.fogDensity = preset.lighting.fog.density || state.fogDensity;
        }

        // Handle legacy format (preset.state)
        if (preset.state) {
          Object.assign(state, preset.state);
        }

        // Update UI sliders
        const pixelSlider = document.getElementById("pixelSlider");
        const reactSlider = document.getElementById("reactSlider");
        const rainSlider = document.getElementById("rainSlider");
        const glowSlider = document.getElementById("glowSlider");
        const imageSizeSlider = document.getElementById("imageSizeSlider");

        if (pixelSlider) {
          pixelSlider.value = state.pixelSize;
          document.getElementById("pixelValue").textContent = state.pixelSize;
        }
        if (reactSlider) {
          reactSlider.value = state.reactivity * 100;
          document.getElementById("reactValue").textContent = `${state.reactivity * 100}%`;
        }
        if (rainSlider) {
          rainSlider.value = state.rainIntensity * 100;
          document.getElementById("rainValue").textContent = `${state.rainIntensity * 100}%`;
        }
        if (glowSlider) {
          glowSlider.value = state.glowAmount * 100;
          document.getElementById("glowValue").textContent = `${state.glowAmount * 100}%`;
        }
        if (imageSizeSlider) {
          imageSizeSlider.value = state.imageScale * 100;
          document.getElementById("imageSizeValue").textContent = `${state.imageScale * 100}%`;
        }

        const moveMode = document.getElementById("moveMode");
        const displayMode = document.getElementById("displayMode");
        const imageLayer = document.getElementById("imageLayer");
        const blendMode = document.getElementById("blendMode");

        if (moveMode) moveMode.value = state.imageMoveMode;
        if (displayMode) displayMode.value = state.imageDisplayMode;
        if (imageLayer) imageLayer.value = state.imageLayer;
        if (blendMode) blendMode.value = state.imageBlendMode;

        utils.updateStatus();
      } catch (err) {
        console.error("Failed to load preset:", err);
        alert("Failed to load preset: " + err.message);
      }
    };
    reader.readAsText(file);
  },

  loadDefaultPreset() {
    fetch('scene-preset-schema.json')
      .then(function(response) {
        if (response.ok) {
          return response.json();
        }
        throw new Error('Failed to fetch preset');
      })
      .then(function(preset) {
        // Create a File-like object from the JSON
        const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
        const file = new File([blob], 'scene-preset-schema.json', { type: 'application/json' });
        utils.loadPreset(file);
        console.log('Default preset loaded:', (preset.metadata && preset.metadata.name) || 'NEON TOKYO');
      })
      .catch(function(err) {
        console.warn('Could not load default preset:', err);
        // Continue without preset - not a critical error
      });
  },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// AUDIO ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const audio = {
  setup(file, showProgress = true) {
    return new Promise((resolve, reject) => {
      try {
        if (!file.type.startsWith("audio/")) {
          reject(new Error("Invalid file type"));
          return;
        }

        const fileId = Date.now() + Math.random();
        const fileObj = {
          id: fileId,
          name: file.name,
          type: "audio",
          file: file,
          loaded: false,
        };

        // Remove old audio file
        const oldAudio = state.loadedFiles.find((f) => f.type === "audio");
        if (oldAudio) {
          const index = state.loadedFiles.findIndex((f) => f.id === oldAudio.id);
          if (index !== -1) {
            state.loadedFiles.splice(index, 1);
          }
        }

        state.loadedFiles.push(fileObj);
        images.updateGallery();

        if (showProgress) {
          images.showProgress(file.name, 0);
        }

        if (audioCtx) {
          audioCtx.close().catch(() => {});
        }

        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        analyser.smoothingTimeConstant = 0.8;
        freqData = new Uint8Array(analyser.frequencyBinCount);

        if (audioElement) {
          audioElement.pause();
          if (audioElement.src.startsWith("blob:")) {
            URL.revokeObjectURL(audioElement.src);
          }
          audioElement.src = "";
        }

        audioElement = new Audio();
        const url = URL.createObjectURL(file);
        audioElement.src = url;
        audioElement.crossOrigin = "anonymous";

        if (showProgress) {
          images.updateProgress(file.name, 50);
        }

        audioElement.addEventListener("loadeddata", () => {
          if (showProgress) {
            images.updateProgress(file.name, 100);
            setTimeout(() => images.hideProgress(file.name), 500);
          }
          fileObj.loaded = true;
          images.updateGallery();
        });

        audioElement.addEventListener("error", (e) => {
          console.error("Audio error:", e);
          this.remove();
          images.removeFile(fileId);
          if (showProgress) {
            images.hideProgress(file.name);
          }
          reject(new Error("Failed to load audio file"));
        });

        const source = audioCtx.createMediaElementSource(audioElement);
        source.connect(analyser);
        analyser.connect(audioCtx.destination);

        fileObj.audioElement = audioElement;
        utils.updateStatus();
        document.getElementById("status").classList.remove("playing");
        resolve();
      } catch (err) {
        console.error("Audio setup error:", err);
        reject(err);
      }
    });
  },

  remove() {
    if (audioElement) {
      audioElement.pause();
      if (audioElement.src.startsWith("blob:")) {
        URL.revokeObjectURL(audioElement.src);
      }
      audioElement.src = "";
      audioElement = null;
    }
    if (audioCtx) {
      audioCtx.close().catch(() => {});
      audioCtx = null;
    }
    analyser = null;
    freqData = new Uint8Array(256);
    state.isPlaying = false;
    document.getElementById("playBtn").textContent = "‚ñ∂ PLAY";
    document.getElementById("status").classList.remove("playing");
    utils.updateStatus();
  },

  process() {
    if (!analyser) {
      return;
    }

    analyser.getByteFrequencyData(freqData);

    // Calculate band averages
    let bass = 0,
      mid = 0,
      high = 0;
    for (let i = 0; i < 8; i++) {
      bass += freqData[i];
    }
    for (let i = 8; i < 32; i++) {
      mid += freqData[i];
    }
    for (let i = 32; i < 64; i++) {
      high += freqData[i];
    }

    state.bassAvg = bass / 8;
    state.midAvg = mid / 24;
    state.highAvg = high / 32;

    // Enhanced beat detection with multiple frequency bands
    const now = performance.now();

    // Calculate beat intensity from multiple sources
    const bassEnergy = state.bassAvg;
    const midEnergy = state.midAvg;
    const highEnergy = state.highAvg;

    // Combined beat intensity
    state.beatIntensity = bassEnergy * 0.5 + midEnergy * 0.3 + highEnergy * 0.2;

    // Store beat history for pattern detection
    state.beatHistory.push({
      time: now,
      intensity: state.beatIntensity,
    });

    // Keep only last 20 beats
    if (state.beatHistory.length > 20) {
      state.beatHistory.shift();
    }

    // Detect beat using dynamic threshold
    const avgIntensity =
      state.beatHistory.length > 0
        ? state.beatHistory.reduce((sum, b) => sum + b.intensity, 0) / state.beatHistory.length
        : 0;
    const threshold = Math.max(150, avgIntensity * 1.3);

    if (state.beatIntensity > threshold && now - state.lastBeatTime > 150) {
      state.beatDetected = true;
      state.lastBeatTime = now;

      // Spawn objects on beat
      beatSpawning.spawnOnBeat(state.beatIntensity);

      setTimeout(() => (state.beatDetected = false), 80);
    }

    // Update frequency bars
    document.querySelectorAll("#freqBars .freq-bar").forEach((bar, i) => {
      bar.style.height = `${(freqData[i * 8] / 255) * 25}px`;
    });

    // Update spectrum visualization
    document.querySelectorAll("#spectrumViz .spectrum-bar").forEach((bar, i) => {
      bar.style.height = `${(freqData[i * 2] / 255) * 50}px`;
    });
  },

  getBandValue(bandName) {
    const band = BANDS[bandName];
    if (!band) {
      return 0;
    }

    let sum = 0;
    for (let i = band.range[0]; i < band.range[1]; i++) {
      sum += freqData[i] || 0;
    }
    return sum / (band.range[1] - band.range[0]);
  },

  applyCurve(value, curve) {
    const normalized = value / 255;
    switch (curve) {
      case "exponential":
        return Math.pow(normalized, 2);
      case "sigmoid":
        return 1 / (1 + Math.exp(-10 * (normalized - 0.5)));
      case "linear":
      default:
        return normalized;
    }
  },

  smoothValue(current, target, smoothing) {
    return current + (target - current) * (1 - smoothing);
  },

  togglePlay() {
    if (!audioElement) {
      return;
    }

    if (state.isPlaying) {
      audioElement.pause().catch((err) => console.error("Pause error:", err));
      state.isPlaying = false;
      document.getElementById("playBtn").textContent = "‚ñ∂ PLAY";
      document.getElementById("status").classList.remove("playing");
    } else {
      audioCtx.resume().catch((err) => console.error("Resume error:", err));
      audioElement
        .play()
        .then(() => {
          state.isPlaying = true;
          document.getElementById("playBtn").textContent = "‚ùö‚ùö PAUSE";
          document.getElementById("status").classList.add("playing");
        })
        .catch((err) => {
          console.error("Play error:", err);
          alert("Failed to play audio. User interaction may be required.");
        });
    }
  },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BACKGROUND REMOVAL SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const backgroundRemoval = {
  // Fast, lightweight background removal
  removeBackground(img, threshold = 0.2) {
    return new Promise((resolve, reject) => {
      try {
        // Limit size for performance
        const maxSize = 600;
        let width = img.width;
        let height = img.height;

        if (width > maxSize || height > maxSize) {
          const scale = Math.min(maxSize / width, maxSize / height);
          width = Math.floor(width * scale);
          height = Math.floor(height * scale);
        }

        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");

        ctx.drawImage(img, 0, 0, width, height);
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // Sample edge pixels for background color
        const edgeSamples = [];
        const sampleSize = 5;
        for (let i = 0; i < sampleSize; i++) {
          // Top edge
          let idx = i * Math.floor(width / sampleSize) * 4;
          edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
          // Bottom edge
          idx = ((height - 1) * width + i * Math.floor(width / sampleSize)) * 4;
          edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
          // Left edge
          idx = i * Math.floor(height / sampleSize) * width * 4;
          edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
          // Right edge
          idx = (i * Math.floor(height / sampleSize) * width + (width - 1)) * 4;
          edgeSamples.push([data[idx], data[idx + 1], data[idx + 2]]);
        }

        // Average background color
        const avgBg = [
          edgeSamples.reduce((s, c) => s + c[0], 0) / edgeSamples.length,
          edgeSamples.reduce((s, c) => s + c[1], 0) / edgeSamples.length,
          edgeSamples.reduce((s, c) => s + c[2], 0) / edgeSamples.length,
        ];

        // Process all pixels (fast enough for small images)
        const thresholdSq = (threshold * 255 * 1.73) ** 2; // sqrt(3) ‚âà 1.73
        for (let i = 0; i < data.length; i += 4) {
          const distSq =
            (data[i] - avgBg[0]) ** 2 +
            (data[i + 1] - avgBg[1]) ** 2 +
            (data[i + 2] - avgBg[2]) ** 2;

          if (distSq < thresholdSq) {
            data[i + 3] = 0; // Transparent
          }
        }

        ctx.putImageData(imageData, 0, 0);

        const processedImg = new Image();
        processedImg.onload = () => resolve(processedImg);
        processedImg.onerror = () => reject(new Error("Image processing failed"));
        processedImg.src = canvas.toDataURL();
      } catch (err) {
        reject(err);
      }
    });
  },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHARACTER CONTROL SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const characterControl = {
  init() {
    // Keyboard event listeners
    window.addEventListener("keydown", (e) => {
      state.keys[e.key.toLowerCase()] = true;
      state.keys[e.code.toLowerCase()] = true;
    });

    window.addEventListener("keyup", (e) => {
      state.keys[e.key.toLowerCase()] = false;
      state.keys[e.code.toLowerCase()] = false;
    });
  },

  update() {
    if (!state.character) {
      return;
    }

    // Reset velocity
    state.characterVelocity.x = 0;
    state.characterVelocity.y = 0;

    // Handle movement input
    if (state.keys["w"] || state.keys["arrowup"] || state.keys["keyw"]) {
      state.characterVelocity.y = -state.characterSpeed;
    }
    if (state.keys["s"] || state.keys["arrowdown"] || state.keys["keys"]) {
      state.characterVelocity.y = state.characterSpeed;
    }
    if (state.keys["a"] || state.keys["arrowleft"] || state.keys["keya"]) {
      state.characterVelocity.x = -state.characterSpeed;
    }
    if (state.keys["d"] || state.keys["arrowright"] || state.keys["keyd"]) {
      state.characterVelocity.x = state.characterSpeed;
    }

    // Normalize diagonal movement
    if (state.characterVelocity.x !== 0 && state.characterVelocity.y !== 0) {
      const len = Math.sqrt(state.characterVelocity.x ** 2 + state.characterVelocity.y ** 2);
      state.characterVelocity.x = (state.characterVelocity.x / len) * state.characterSpeed;
      state.characterVelocity.y = (state.characterVelocity.y / len) * state.characterSpeed;
    }

    // Update character position
    state.character.x += state.characterVelocity.x;
    state.character.y += state.characterVelocity.y;

    // Keep character within world bounds
    const charWidth = state.character.img.width * state.character.scale * 0.5;
    const charHeight = state.character.img.height * state.character.scale * 0.5;

    state.character.x = Math.max(
      state.worldBounds.minX + charWidth,
      Math.min(state.worldBounds.maxX - charWidth, state.character.x)
    );
    state.character.y = Math.max(
      state.worldBounds.minY + charHeight,
      Math.min(state.worldBounds.maxY - charHeight, state.character.y)
    );

    // Update base position for smooth transitions
    state.character.baseX = state.character.x;
    state.character.baseY = state.character.y;

    // Auto-wander when no input (subtle random movement)
    if (state.characterVelocity.x === 0 && state.characterVelocity.y === 0) {
      const wanderStrength = 0.3;
      state.character.x += (Math.random() - 0.5) * wanderStrength;
      state.character.y += (Math.random() - 0.5) * wanderStrength;

      // Keep in bounds
      state.character.x = Math.max(
        state.worldBounds.minX + charWidth,
        Math.min(state.worldBounds.maxX - charWidth, state.character.x)
      );
      state.character.y = Math.max(
        state.worldBounds.minY + charHeight,
        Math.min(state.worldBounds.maxY - charHeight, state.character.y)
      );
    }
  },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BEAT-BASED SPAWNING SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const beatSpawning = {
  spawnOnBeat(beatIntensity) {
    const now = performance.now();
    if (now - state.lastSpawnTime < state.spawnCooldown) {
      return;
    }

    // Spawn based on beat intensity
    const spawnChance = Math.min(0.8, beatIntensity * 0.01);
    if (Math.random() > spawnChance) {
      return;
    }

    state.lastSpawnTime = now;

    // Determine spawn type based on beat intensity
    const types = ["particle", "glow", "trail", "explosion"];
    const type = types[Math.floor(Math.random() * types.length)];

    // Spawn near character if available, otherwise random
    let spawnX, spawnY;
    if (state.character) {
      const offset = 50 + Math.random() * 100;
      const angle = Math.random() * Math.PI * 2;
      spawnX = state.character.x + Math.cos(angle) * offset;
      spawnY = state.character.y + Math.sin(angle) * offset;
    } else {
      spawnX = Math.random() * CONFIG.SCENE_WIDTH;
      spawnY = Math.random() * CONFIG.SCENE_HEIGHT;
    }

    // Create spawned object
    const obj = {
      type,
      x: spawnX,
      y: spawnY,
      vx: (Math.random() - 0.5) * 2,
      vy: (Math.random() - 0.5) * 2,
      life: 1.0,
      maxLife: 1.0 + Math.random() * 2,
      size: 5 + Math.random() * 15,
      color: CONFIG.PALETTE.neon[Math.floor(Math.random() * CONFIG.PALETTE.neon.length)],
      rotation: Math.random() * Math.PI * 2,
      rotationSpeed: (Math.random() - 0.5) * 0.1,
      glow: 0.5 + Math.random() * 0.5,
    };

    entities.spawnedObjects.push(obj);
  },

  update() {
    // Update and remove expired objects
    for (let i = entities.spawnedObjects.length - 1; i >= 0; i--) {
      const obj = entities.spawnedObjects[i];

      obj.x += obj.vx;
      obj.y += obj.vy;
      obj.rotation += obj.rotationSpeed;
      obj.life -= 0.02;

      // Apply gravity/friction
      obj.vx *= 0.98;
      obj.vy *= 0.98;

      // Remove if expired
      if (obj.life <= 0) {
        entities.spawnedObjects.splice(i, 1);
      }
    }
  },

  render(ctx) {
    entities.spawnedObjects.forEach((obj) => {
      const alpha = obj.life / obj.maxLife;
      ctx.save();
      ctx.globalAlpha = alpha * obj.glow;
      ctx.translate(obj.x, obj.y);
      ctx.rotate(obj.rotation);

      switch (obj.type) {
        case "particle":
          ctx.fillStyle = obj.color;
          ctx.beginPath();
          ctx.arc(0, 0, obj.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 20;
          ctx.shadowColor = obj.color;
          ctx.fill();
          break;

        case "glow":
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, obj.size * 2);
          gradient.addColorStop(0, obj.color);
          gradient.addColorStop(1, "transparent");
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, obj.size * 2, 0, Math.PI * 2);
          ctx.fill();
          break;

        case "trail":
          ctx.strokeStyle = obj.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(-obj.size, 0);
          ctx.lineTo(obj.size, 0);
          ctx.stroke();
          break;

        case "explosion":
          for (let i = 0; i < 8; i++) {
            const angle = ((Math.PI * 2) / 8) * i;
            ctx.fillStyle = obj.color;
            ctx.beginPath();
            ctx.arc(
              Math.cos(angle) * obj.size,
              Math.sin(angle) * obj.size,
              obj.size * 0.3,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
          break;
      }

      ctx.restore();
    });
  },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// IMAGE SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const images = {
  load(file, showProgress = true) {
    return new Promise((resolve, reject) => {
      if (!file.type.startsWith("image/")) {
        reject(new Error("Invalid file type"));
        return;
      }

      const fileId = Date.now() + Math.random();
      const fileObj = {
        id: fileId,
        name: file.name,
        type: "image",
        file: file,
        loaded: false,
      };

      state.loadedFiles.push(fileObj);
      this.updateGallery();

      if (showProgress) {
        this.showProgress(file.name, 0);
      }

      const reader = new FileReader();
      reader.onprogress = (e) => {
        if (e.lengthComputable && showProgress) {
          const percent = (e.loaded / e.total) * 100;
          this.updateProgress(file.name, percent);
        }
      };

      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          // Process background removal for character images (non-blocking)
          const processedImg = img;
          const isFirstImage = entities.images.length === 0;

          if (showProgress) {
            this.updateProgress(file.name, 50);
          }

          // Start background removal asynchronously (non-blocking)
          if (isFirstImage && img.width * img.height < 1000000) {
            // Only process first image (character) for background removal
            // Skip if image is too large (>1M pixels)
            const timeout = setTimeout(() => {
              console.warn("Background removal timeout, using original");
            }, 5000);

            backgroundRemoval
              .removeBackground(img, 0.2)
              .then((result) => {
                clearTimeout(timeout);
                // Update the image when processing completes
                const imgObj = entities.images.find((i) => i.fileId === fileId);
                if (imgObj) {
                  imgObj.img = result;
                }
              })
              .catch((err) => {
                clearTimeout(timeout);
                console.warn("Background removal failed, using original:", err);
              });
          }

          const imgObj = {
            img: processedImg,
            originalImg: img,
            fileId,
            x: CONFIG.SCENE_WIDTH / 2,
            y: CONFIG.SCENE_HEIGHT / 2,
            baseX: CONFIG.SCENE_WIDTH / 2,
            baseY: CONFIG.SCENE_HEIGHT / 2,
            scale: 1.0,
            rotation: 0,
            alpha: 1.0,
            phase: Math.random() * Math.PI * 2,
            orbitRadius: 50 + Math.random() * 100,
            orbitSpeed: 0.01 + Math.random() * 0.02,
            blendMode: state.imageBlendMode,
            isCharacter: isFirstImage, // First image becomes the character
            audioMapping: {
              band: "bass",
              targets: {
                scale: true,
                rotation: false,
                x: false,
                y: false,
                alpha: false,
                hue: false,
              },
              sensitivity: 1.0,
              curve: "linear",
              smoothing: 0.7,
            },
            hueShift: 0,
          };

          entities.images.push(imgObj);

          // Set as character if it's the first image
          if (isFirstImage) {
            state.character = imgObj;
            imgObj.x = CONFIG.SCENE_WIDTH / 2;
            imgObj.y = CONFIG.SCENE_HEIGHT / 2;
            imgObj.baseX = imgObj.x;
            imgObj.baseY = imgObj.y;
          }

          fileObj.loaded = true;
          fileObj.imgObj = imgObj;

          if (showProgress) {
            this.updateProgress(file.name, 100);
            setTimeout(() => this.hideProgress(file.name), 500);
          }

          this.updateGallery();
          utils.updateStatus();
          resolve(imgObj);
        };
        img.onerror = () => {
          this.removeFile(fileId);
          if (showProgress) {
            this.hideProgress(file.name);
          }
          reject(new Error("Failed to load image"));
        };
        img.src = e.target.result;
      };
      reader.onerror = () => {
        this.removeFile(fileId);
        if (showProgress) {
          this.hideProgress(file.name);
        }
        reject(new Error("Failed to read file"));
      };
      reader.readAsDataURL(file);
    });
  },

  remove(fileId) {
    const index = entities.images.findIndex((img) => img.fileId === fileId);
    if (index !== -1) {
      const imgObj = entities.images[index];
      // If removing character, set next image as character
      if (imgObj.isCharacter && entities.images.length > 1) {
        const nextImg = entities.images.find((img) => img !== imgObj);
        if (nextImg) {
          nextImg.isCharacter = true;
          state.character = nextImg;
        } else {
          state.character = null;
        }
      } else if (imgObj.isCharacter) {
        state.character = null;
      }
      entities.images.splice(index, 1);
    }
    this.removeFile(fileId);
    utils.updateStatus();
  },

  removeFile(fileId) {
    const index = state.loadedFiles.findIndex((f) => f.id === fileId);
    if (index !== -1) {
      state.loadedFiles.splice(index, 1);
      this.updateGallery();
    }
  },

  updateGallery() {
    const gallery = document.getElementById("fileGallery");
    gallery.innerHTML = "";

    state.loadedFiles.forEach((fileObj) => {
      const item = document.createElement("div");
      item.className = `file-item ${fileObj.type} ${fileObj.loaded ? "" : "loading"}`;
      item.dataset.fileId = fileObj.id;

      if (fileObj.type === "image" && fileObj.loaded && fileObj.imgObj) {
        const img = document.createElement("img");
        img.src = fileObj.imgObj.img.src;
        img.onerror = () => {
          item.innerHTML = '<div class="file-icon">üñºÔ∏è</div>';
        };
        item.appendChild(img);
      } else if (fileObj.type === "audio") {
        item.innerHTML = '<div class="file-icon">üéµ</div>';
      } else {
        item.innerHTML = '<div class="file-icon">üìÑ</div>';
      }

      const name = document.createElement("div");
      name.className = "file-name";
      name.textContent =
        fileObj.name.length > 15 ? fileObj.name.substring(0, 12) + "..." : fileObj.name;
      item.appendChild(name);

      const removeBtn = document.createElement("button");
      removeBtn.className = "remove-btn";
      removeBtn.textContent = "√ó";
      removeBtn.onclick = (e) => {
        e.stopPropagation();
        if (fileObj.type === "image") {
          this.remove(fileObj.id);
        } else if (fileObj.type === "audio") {
          audio.remove();
          this.removeFile(fileObj.id);
        }
      };
      item.appendChild(removeBtn);

      if (fileObj.type === "image" && fileObj.loaded && fileObj.imgObj) {
        item.onclick = () => {
          ui.openAudioPanel(fileObj.imgObj);
        };
      }

      gallery.appendChild(item);
    });
  },

  showProgress(fileName, percent) {
    const progress = document.getElementById("uploadProgress");
    progress.classList.add("active");

    let item = progress.querySelector(`[data-file="${fileName}"]`);
    if (!item) {
      item = document.createElement("div");
      item.className = "progress-item";
      item.dataset.file = fileName;
      item.innerHTML = `
                <span class="progress-name">${fileName}</span>
                <div class="progress-bar"><div class="progress-fill" style="width: ${percent}%"></div></div>
            `;
      progress.appendChild(item);
    }
  },

  updateProgress(fileName, percent) {
    const item = document
      .getElementById("uploadProgress")
      .querySelector(`[data-file="${fileName}"]`);
    if (item) {
      const fill = item.querySelector(".progress-fill");
      if (fill) {
        fill.style.width = percent + "%";
      }
    }
  },

  hideProgress(fileName) {
    const item = document
      .getElementById("uploadProgress")
      .querySelector(`[data-file="${fileName}"]`);
    if (item) {
      item.remove();
      if (document.getElementById("uploadProgress").children.length === 0) {
        document.getElementById("uploadProgress").classList.remove("active");
      }
    }
  },

  update() {
    // Update character control
    characterControl.update();

    const isFullscreenMode =
      state.imageDisplayMode === "fullscreen" || state.imageDisplayMode === "tiled";

    entities.images.forEach((imgObj, i) => {
      const map = imgObj.audioMapping;
      const rawBandValue = audio.getBandValue(map.band);
      const curvedValue = audio.applyCurve(rawBandValue, map.curve);
      const bandValue = curvedValue * map.sensitivity;

      if (!BANDS[map.band].smoothed) {
        BANDS[map.band].smoothed = 0;
      }
      BANDS[map.band].smoothed = audio.smoothValue(
        BANDS[map.band].smoothed,
        bandValue,
        map.smoothing
      );
      const smoothedValue = BANDS[map.band].smoothed;

      const audioScale = 1 + smoothedValue * 0.3 * state.reactivity;

      if (isFullscreenMode) {
        imgObj.baseX = CONFIG.SCENE_WIDTH / 2;
        imgObj.baseY = CONFIG.SCENE_HEIGHT / 2;
      }

      // Skip automatic movement for character when being controlled
      const isCharacterControlled =
        imgObj.isCharacter &&
        (state.keys["w"] ||
          state.keys["s"] ||
          state.keys["a"] ||
          state.keys["d"] ||
          state.keys["arrowup"] ||
          state.keys["arrowdown"] ||
          state.keys["arrowleft"] ||
          state.keys["arrowright"]);

      if (!isCharacterControlled) {
        // Apply movement mode
        this.applyMovement(imgObj, i, isFullscreenMode);
      }

      // Apply audio targets
      if (map.targets.scale) {
        imgObj.scale *= audioScale;
      }
      if (map.targets.rotation) {
        imgObj.rotation += smoothedValue * 0.1;
      }
      if (map.targets.x && !isCharacterControlled) {
        imgObj.x += (smoothedValue - 0.5) * (isFullscreenMode ? 200 : 100);
      }
      if (map.targets.y && !isCharacterControlled) {
        imgObj.y += (smoothedValue - 0.5) * (isFullscreenMode ? 200 : 100);
      }
      if (map.targets.alpha) {
        imgObj.alpha = 0.3 + smoothedValue * 0.7;
      } else {
        imgObj.alpha = 0.7 + (state.midAvg / 255) * 0.3 * state.reactivity;
      }
      if (map.targets.hue) {
        imgObj.hueShift = smoothedValue * 360;
      } else {
        imgObj.hueShift = 0;
      }

      if (state.beatDetected) {
        imgObj.scale *= 1.15;
      }
    });
  },

  applyMovement(imgObj, index, isFullscreenMode) {
    const t = state.t;
    const scale = state.imageScale;

    switch (state.imageMoveMode) {
      case "float":
        imgObj.x = imgObj.baseX + Math.sin(t * 0.02 + imgObj.phase) * (isFullscreenMode ? 50 : 30);
        imgObj.y = imgObj.baseY + Math.cos(t * 0.015 + imgObj.phase) * (isFullscreenMode ? 30 : 20);
        imgObj.scale = scale * (0.9 + Math.sin(t * 0.03 + imgObj.phase) * 0.1);
        break;
      case "bounce":
        const bounce =
          Math.max(0, state.bassAvg / 255 - 0.3) * (isFullscreenMode ? 50 : 100) * state.reactivity;
        imgObj.x = imgObj.baseX;
        imgObj.y = imgObj.baseY - bounce;
        imgObj.scale = scale;
        break;
      case "orbit":
        const angle = t * imgObj.orbitSpeed + imgObj.phase;
        const radius = isFullscreenMode ? imgObj.orbitRadius * 0.5 : imgObj.orbitRadius;
        imgObj.x = imgObj.baseX + Math.cos(angle) * radius;
        imgObj.y = imgObj.baseY + Math.sin(angle) * radius;
        imgObj.scale = scale;
        imgObj.rotation = isFullscreenMode ? 0 : angle;
        break;
      case "wave":
        imgObj.x = imgObj.baseX + Math.sin(t * 0.03 + index * 0.5) * (isFullscreenMode ? 100 : 80);
        imgObj.y = imgObj.baseY + Math.sin(t * 0.02 + index * 0.3) * 60;
        imgObj.scale = scale * (1 + Math.sin(t * 0.04 + index) * 0.2);
        imgObj.rotation = isFullscreenMode ? 0 : Math.sin(t * 0.02 + index) * 0.3;
        break;
      case "spin":
        imgObj.x = imgObj.baseX;
        imgObj.y = imgObj.baseY;
        imgObj.rotation += 0.02;
        imgObj.scale = scale;
        break;
      case "pulse":
        imgObj.x = imgObj.baseX;
        imgObj.y = imgObj.baseY;
        imgObj.scale = scale * (0.8 + Math.sin(t * 0.1) * 0.2);
        break;
    }
  },

  render() {
    if (entities.images.length === 0) {
      return;
    }

    switch (state.imageDisplayMode) {
      case "fullscreen":
        this.renderFullscreen();
        break;
      case "tiled":
        this.renderTiled();
        break;
      default:
        this.renderFloating();
        break;
    }
  },

  renderFullscreen() {
    entities.images.forEach((imgObj) => {
      sceneCtx.save();
      this.applyBlendMode(imgObj.blendMode);
      sceneCtx.globalAlpha = imgObj.alpha;

      // Enhanced image rendering quality
      sceneCtx.imageSmoothingEnabled = true;
      sceneCtx.imageSmoothingQuality = "high";

      const centerX = CONFIG.SCENE_WIDTH / 2;
      const centerY = CONFIG.SCENE_HEIGHT / 2;
      sceneCtx.translate(centerX, centerY);
      sceneCtx.rotate(imgObj.rotation);

      if (imgObj.hueShift !== 0) {
        sceneCtx.filter = `hue-rotate(${imgObj.hueShift}deg)`;
      }

      const imgAspect = imgObj.img.width / imgObj.img.height;
      const screenAspect = CONFIG.SCENE_WIDTH / CONFIG.SCENE_HEIGHT;

      let drawW, drawH;
      if (imgAspect > screenAspect) {
        drawH = CONFIG.SCENE_HEIGHT * imgObj.scale;
        drawW = drawH * imgAspect;
      } else {
        drawW = CONFIG.SCENE_WIDTH * imgObj.scale;
        drawH = drawW / imgAspect;
      }

      const offsetX = imgObj.x - imgObj.baseX;
      const offsetY = imgObj.y - imgObj.baseY;

      sceneCtx.drawImage(imgObj.img, -drawW / 2 + offsetX, -drawH / 2 + offsetY, drawW, drawH);
      sceneCtx.filter = "none";

      if (state.beatDetected && state.glowAmount > 0.5) {
        sceneCtx.shadowColor = CONFIG.PALETTE.primary;
        sceneCtx.shadowBlur = 40;
        sceneCtx.drawImage(imgObj.img, -drawW / 2 + offsetX, -drawH / 2 + offsetY, drawW, drawH);
        sceneCtx.shadowBlur = 0;
      }

      sceneCtx.restore();
    });
  },

  renderTiled() {
    entities.images.forEach((imgObj) => {
      sceneCtx.save();
      this.applyBlendMode(imgObj.blendMode);
      sceneCtx.globalAlpha = imgObj.alpha;

      // Enhanced image rendering quality
      sceneCtx.imageSmoothingEnabled = true;
      sceneCtx.imageSmoothingQuality = "high";

      if (imgObj.hueShift !== 0) {
        sceneCtx.filter = `hue-rotate(${imgObj.hueShift}deg)`;
      }

      const baseTileSize = 150;
      const tileW = baseTileSize * imgObj.scale;
      const tileH = tileW * (imgObj.img.height / imgObj.img.width);

      const offsetX = (imgObj.x - imgObj.baseX) % tileW;
      const offsetY = (imgObj.y - imgObj.baseY) % tileH;

      const numX = Math.ceil(CONFIG.SCENE_WIDTH / tileW) + 2;
      const numY = Math.ceil(CONFIG.SCENE_HEIGHT / tileH) + 2;

      for (let ty = -1; ty < numY; ty++) {
        for (let tx = -1; tx < numX; tx++) {
          const x = tx * tileW + offsetX;
          const y = ty * tileH + offsetY;

          sceneCtx.save();
          sceneCtx.translate(x + tileW / 2, y + tileH / 2);
          sceneCtx.rotate(imgObj.rotation);
          sceneCtx.drawImage(imgObj.img, -tileW / 2, -tileH / 2, tileW, tileH);
          sceneCtx.restore();
        }
      }

      sceneCtx.filter = "none";
      sceneCtx.restore();
    });
  },

  renderFloating() {
    entities.images.forEach((imgObj) => {
      sceneCtx.save();
      this.applyBlendMode(imgObj.blendMode);
      sceneCtx.globalAlpha = imgObj.alpha;

      // Enhanced image rendering quality
      sceneCtx.imageSmoothingEnabled = true;
      sceneCtx.imageSmoothingQuality = "high";

      sceneCtx.translate(imgObj.x, imgObj.y);
      sceneCtx.rotate(imgObj.rotation);
      sceneCtx.scale(imgObj.scale, imgObj.scale);

      if (imgObj.hueShift !== 0) {
        sceneCtx.filter = `hue-rotate(${imgObj.hueShift}deg)`;
      }

      const aspectRatio = imgObj.img.width / imgObj.img.height;
      const maxSize = 200;
      const drawW = aspectRatio > 1 ? maxSize : maxSize * aspectRatio;
      const drawH = aspectRatio > 1 ? maxSize / aspectRatio : maxSize;

      sceneCtx.drawImage(imgObj.img, -drawW / 2, -drawH / 2, drawW, drawH);
      sceneCtx.filter = "none";

      // Enhanced glow on beat
      if (state.beatDetected && state.glowAmount > 0.5) {
        const glowIntensity = 1 + (state.bassAvg / 255) * 0.5;

        // Outer glow
        sceneCtx.shadowColor = CONFIG.PALETTE.primary;
        sceneCtx.shadowBlur = 50 * glowIntensity;
        sceneCtx.globalAlpha = 0.6;
        sceneCtx.drawImage(imgObj.img, -drawW / 2, -drawH / 2, drawW, drawH);

        // Middle glow
        sceneCtx.shadowBlur = 30 * glowIntensity;
        sceneCtx.globalAlpha = 0.8;
        sceneCtx.drawImage(imgObj.img, -drawW / 2, -drawH / 2, drawW, drawH);

        // Core
        sceneCtx.shadowBlur = 0;
        sceneCtx.globalAlpha = 1;
      }

      // Character indicator (pulsing glow)
      if (imgObj.isCharacter) {
        const pulse = 1 + Math.sin(state.t * 0.1) * 0.1;
        sceneCtx.shadowColor = CONFIG.PALETTE.highlight;
        sceneCtx.shadowBlur = 30 * pulse;
        sceneCtx.globalAlpha = 0.7 * pulse;
        sceneCtx.drawImage(imgObj.img, -drawW / 2, -drawH / 2, drawW, drawH);
        sceneCtx.shadowBlur = 0;
        sceneCtx.globalAlpha = 1;

        // Character control indicator
        if (state.characterVelocity.x !== 0 || state.characterVelocity.y !== 0) {
          sceneCtx.strokeStyle = CONFIG.PALETTE.highlight;
          sceneCtx.lineWidth = 2;
          sceneCtx.setLineDash([3, 3]);
          sceneCtx.strokeRect(-drawW / 2 - 8, -drawH / 2 - 8, drawW + 16, drawH + 16);
          sceneCtx.setLineDash([]);
        }
      }

      // Outlines
      if (imgObj === state.selectedImage) {
        sceneCtx.globalAlpha = 1;
        sceneCtx.strokeStyle = CONFIG.PALETTE.secondary;
        sceneCtx.lineWidth = 3;
        sceneCtx.setLineDash([5, 5]);
        sceneCtx.strokeRect(-drawW / 2 - 5, -drawH / 2 - 5, drawW + 10, drawH + 10);
        sceneCtx.setLineDash([]);
      }

      if (state.isDragging && imgObj === state.draggedImage) {
        sceneCtx.globalAlpha = 1;
        sceneCtx.strokeStyle = CONFIG.PALETTE.accent;
        sceneCtx.lineWidth = 2;
        sceneCtx.strokeRect(-drawW / 2 - 3, -drawH / 2 - 3, drawW + 6, drawH + 6);
      }

      sceneCtx.restore();
    });
  },

  applyBlendMode(mode) {
    switch (mode) {
      case "screen":
        sceneCtx.globalCompositeOperation = "screen";
        break;
      case "multiply":
        sceneCtx.globalCompositeOperation = "multiply";
        break;
      case "overlay":
        sceneCtx.globalCompositeOperation = "overlay";
        break;
      default:
        sceneCtx.globalCompositeOperation = "source-over";
        break;
    }
  },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SCENE RENDERING (Simplified - buildings, people, cars, rain, etc.)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const scene = {
  init() {
    // Initialize buildings, people, cars, rain
    this.initBuildings();
    this.initPeople();
    this.initCars();
    this.initRain();
  },

  initBuildings() {
    const specs = [
      { x: 0, w: 70, h: 200, sign: null },
      { x: 80, w: 55, h: 290, sign: { text: "„Éõ„ÉÜ„É´", color: "#ff00ff", y: 80 } },
      { x: 145, w: 95, h: 175, sign: { text: "ÈÖíÂ†¥", color: "#ff6b00", y: 100 } },
      { x: 250, w: 65, h: 330, spire: true },
      { x: 325, w: 100, h: 160, sign: { text: "CLUB", color: "#00f5ff", y: 90 } },
      { x: 435, w: 60, h: 270, sign: { text: "24H", color: "#39ff14", y: 120 } },
      { x: 505, w: 85, h: 195 },
      { x: 600, w: 70, h: 250, sign: { text: "BAR", color: "#ff0055", y: 140 } },
      { x: 680, w: 60, h: 180 },
      { x: 750, w: 50, h: 220 },
    ];

    specs.forEach((s, i) => {
      const windowRows = Math.floor(s.h / 14);
      const windowCols = Math.floor(s.w / 14);
      const windows = [];

      for (let r = 0; r < windowRows; r++) {
        for (let c = 0; c < windowCols; c++) {
          windows.push({
            x: s.x + 5 + c * 13,
            y: CONFIG.SCENE_HEIGHT - s.h + 8 + r * 14,
            lit: Math.random() > 0.3,
            flicker: Math.random() < 0.05,
            hue: Math.random() * 30 + 30,
          });
        }
      }

      entities.buildings.push({
        ...s,
        windows,
        baseY: CONFIG.SCENE_HEIGHT - s.h,
        pulsePhase: Math.random() * Math.PI * 2,
      });
    });
  },

  initPeople() {
    const hairColors = ["#111", "#222", "#331100", "#ff00ff", "#00f5ff"];
    const clothesColors = ["#111", "#222", "#333", "#ff0055", "#00f5ff", "#ff00ff", "#006633"];

    for (let i = 0; i < 40; i++) {
      const hasUmbrella = Math.random() < 0.4;
      entities.people.push({
        x: Math.random() * CONFIG.SCENE_WIDTH,
        y: 320 + Math.random() * 35,
        vx: (Math.random() - 0.5) * 1.5,
        height: 28 + Math.random() * 15,
        behavior: Math.random() < 0.6 ? "walk" : Math.random() < 0.5 ? "stand" : "dance",
        phase: Math.random() * Math.PI * 2,
        hairColor: hairColors[Math.floor(Math.random() * hairColors.length)],
        clothesColor: clothesColors[Math.floor(Math.random() * clothesColors.length)],
        umbrella: hasUmbrella,
        umbrellaColor: hasUmbrella
          ? CONFIG.PALETTE.neon[Math.floor(Math.random() * CONFIG.PALETTE.neon.length)]
          : null,
        armUp: false,
      });
    }
  },

  initCars() {
    const lanes = [
      { y: 375, dir: 1, speed: 2.5 },
      { y: 395, dir: 1, speed: 3.5 },
      { y: 415, dir: -1, speed: 3 },
      { y: 435, dir: -1, speed: 4 },
    ];

    const types = [
      { name: "sedan", w: 55, h: 22, weight: 0.35 },
      { name: "sports", w: 60, h: 18, weight: 0.15 },
      { name: "suv", w: 65, h: 28, weight: 0.2 },
      { name: "taxi", w: 55, h: 22, weight: 0.2, color: "#ccaa00" },
      { name: "police", w: 58, h: 24, weight: 0.1, lights: true, color: "#111" },
    ];

    const colors = ["#1a1a1a", "#2a2a2a", "#0a0a0a", "#330000", "#000033", "#003300"];

    for (let i = 0; i < 16; i++) {
      const lane = lanes[i % lanes.length];
      const type = utils.weightedRandom(types);

      entities.cars.push({
        x: Math.random() * CONFIG.SCENE_WIDTH * 1.5 - CONFIG.SCENE_WIDTH * 0.25,
        y: lane.y,
        w: type.w,
        h: type.h,
        dir: lane.dir,
        speed: lane.speed * (0.8 + Math.random() * 0.4),
        color: type.color || colors[Math.floor(Math.random() * colors.length)],
        hasLights: type.lights || false,
        lightPhase: Math.random() * Math.PI * 2,
        braking: false,
      });
    }
  },

  initRain() {
    for (let i = 0; i < 200; i++) {
      const drop = pools.get("raindrops") || {};
      drop.x = Math.random() * CONFIG.SCENE_WIDTH;
      drop.y = Math.random() * CONFIG.SCENE_HEIGHT;
      drop.speed = 8 + Math.random() * 6;
      drop.length = 10 + Math.random() * 15;
      entities.raindrops.push(drop);
    }
  },

  update() {
    this.updatePeople();
    this.updateCars();
    this.updateRain();
    this.updateParticles();
  },

  updatePeople() {
    entities.people.forEach((p) => {
      if (p.behavior === "walk") {
        p.x += p.vx * (1 + (state.bassAvg / 255) * 0.3 * state.reactivity);
        if (p.x < -30) {
          p.x = CONFIG.SCENE_WIDTH + 30;
        }
        if (p.x > CONFIG.SCENE_WIDTH + 30) {
          p.x = -30;
        }
      } else if (p.behavior === "dance") {
        p.x += Math.sin(state.t * 0.1 + p.phase) * 0.5;
      }

      if (state.beatDetected && Math.random() < 0.3) {
        p.armUp = true;
        setTimeout(() => (p.armUp = false), 300);
      }
    });
  },

  updateCars() {
    entities.cars.forEach((car) => {
      const speedMod = 1 + (state.bassAvg / 255) * 0.5 * state.reactivity;
      car.x += car.speed * car.dir * speedMod;

      if (car.dir > 0 && car.x > CONFIG.SCENE_WIDTH + 100) {
        car.x = -car.w - 50;
      }
      if (car.dir < 0 && car.x < -car.w - 50) {
        car.x = CONFIG.SCENE_WIDTH + 100;
      }

      if (Math.random() < 0.002) {
        car.braking = true;
        setTimeout(() => (car.braking = false), 500);
      }
    });
  },

  updateRain() {
    if (state.rainIntensity <= 0) {
      return;
    }

    entities.raindrops.forEach((drop) => {
      drop.x += 2 * state.rainIntensity;
      drop.y += drop.speed * state.rainIntensity;

      if (drop.y > 360) {
        if (Math.random() < 0.3) {
          const splash = pools.get("splashes") || {};
          splash.x = drop.x;
          splash.y = 360 + Math.random() * 20;
          splash.radius = 2;
          splash.maxRadius = 5 + Math.random() * 3;
          splash.alpha = 0.6;
          entities.splashes.push(splash);
        }
        drop.x = Math.random() * CONFIG.SCENE_WIDTH;
        drop.y = -drop.length;
      }
    });

    for (let i = entities.splashes.length - 1; i >= 0; i--) {
      const splash = entities.splashes[i];
      splash.radius += 0.5;
      splash.alpha -= 0.08;
      if (splash.alpha <= 0) {
        pools.release("splashes", splash);
        entities.splashes.splice(i, 1);
      }
    }
  },

  updateParticles() {
    // Steam
    if (Math.random() < 0.1) {
      const spawnPoints = [100, 300, 500, 700];
      const x = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
      entities.steamParticles.push({
        x: x + Math.random() * 20 - 10,
        y: 360,
        size: 10 + Math.random() * 20,
        alpha: 0.15,
        vy: -0.5 - Math.random() * 0.5,
      });
    }

    for (let i = entities.steamParticles.length - 1; i >= 0; i--) {
      const p = entities.steamParticles[i];
      p.y += p.vy;
      p.x += Math.sin(state.t * 0.05 + i) * 0.3;
      p.size += 0.2;
      p.alpha -= 0.002;
      if (p.alpha <= 0 || p.y < 200) {
        pools.release("steam", p);
        entities.steamParticles.splice(i, 1);
      }
    }

    // Enhanced sparks with more variety
    if (state.beatDetected && Math.random() < 0.4) {
      const x = 100 + Math.random() * 600;
      const count = 15 + Math.floor(state.bassAvg / 20);
      for (let i = 0; i < count; i++) {
        const spark = pools.get("sparks") || {};
        spark.x = x + (Math.random() - 0.5) * 20;
        spark.y = 100 + Math.random() * 50;
        spark.vx = (Math.random() - 0.5) * 6;
        spark.vy = -Math.random() * 4 - 1;
        spark.life = 1;
        spark.prevX = spark.x;
        spark.prevY = spark.y;
        entities.sparks.push(spark);
      }
    }

    for (let i = entities.sparks.length - 1; i >= 0; i--) {
      const s = entities.sparks[i];
      s.x += s.vx;
      s.y += s.vy;
      s.vy += 0.2;
      s.vx *= 0.98; // Air resistance
      s.life -= 0.04;
      if (s.life <= 0 || s.y > CONFIG.SCENE_HEIGHT + 50) {
        pools.release("sparks", s);
        entities.sparks.splice(i, 1);
      }
    }
  },

  render() {
    // Save previous frame for motion blur
    if (state.motionBlur > 0 && previousFrameCtx) {
      previousFrameCtx.clearRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
      previousFrameCtx.drawImage(sceneCanvas, 0, 0);
    }

    sceneCtx.clearRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);

    this.renderSky();
    this.renderBuildings();
    this.renderGround();
    this.renderParticles();
    this.renderCars();
    this.renderPeople();
    this.renderRain();

    // Apply post-processing
    this.applyPostProcessing();
  },

  applyPostProcessing() {
    if (!postProcessCtx) {
      return;
    }

    if (state.bloomIntensity > 0 || state.chromaticAberration > 0 || state.motionBlur > 0) {
      // Copy scene to post-process buffer
      postProcessCtx.clearRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
      postProcessCtx.drawImage(sceneCanvas, 0, 0);

      // Apply bloom
      if (state.bloomIntensity > 0) {
        this.applyBloom();
      }

      // Apply motion blur
      if (state.motionBlur > 0 && previousFrameCtx) {
        sceneCtx.globalAlpha = state.motionBlur * 0.3;
        sceneCtx.drawImage(previousFrameCanvas, 0, 0);
        sceneCtx.globalAlpha = 1;
      }

      // Apply chromatic aberration
      if (state.chromaticAberration > 0) {
        this.applyChromaticAberration();
      }
    }

    // Apply volumetric fog
    if (state.fogDensity > 0) {
      this.applyVolumetricFog();
    }
  },

  applyBloom() {
    const intensity = state.bloomIntensity * (1 + (state.bassAvg / 255) * 0.4);

    if (!bloomCtx) {
      return;
    }

    // Enhanced bloom extraction with better threshold
    bloomCtx.clearRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
    bloomCtx.drawImage(postProcessCanvas, 0, 0);

    const imageData = bloomCtx.getImageData(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
    const data = imageData.data;
    const threshold = 120; // Lower threshold for more bloom

    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      // Use perceptual luminance for better results
      const brightness = r * 0.299 + g * 0.587 + b * 0.114;

      if (brightness > threshold) {
        // Enhanced bloom with smooth falloff
        const factor = Math.pow((brightness - threshold) / (255 - threshold), 1.5) * intensity;
        const boost = 1.0 + factor * 0.8;

        data[i] = Math.min(255, r * boost);
        data[i + 1] = Math.min(255, g * boost);
        data[i + 2] = Math.min(255, b * boost);
      } else {
        // Darken non-bloom areas more smoothly
        const darken = 0.92 + (brightness / threshold) * 0.08;
        data[i] *= darken;
        data[i + 1] *= darken;
        data[i + 2] *= darken;
      }
    }

    bloomCtx.putImageData(imageData, 0, 0);

    // Apply Gaussian blur simulation using a separable box blur
    const blurData = bloomCtx.getImageData(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
    const pixels = blurData.data;
    const width = CONFIG.SCENE_WIDTH;
    const height = CONFIG.SCENE_HEIGHT;
    const radius = 2;
    const temp = new Uint8ClampedArray(pixels.length);

    // Perform a small number of separable blur passes for a stronger effect
    for (let pass = 0; pass < 2; pass++) {
      // Horizontal blur: pixels -> temp
      for (let y = 0; y < height; y++) {
        const rowOffset = y * width * 4;
        for (let x = 0; x < width; x++) {
          let r = 0,
            g = 0,
            b = 0,
            count = 0;
          for (let dx = -radius; dx <= radius; dx++) {
            const sx = Math.min(width - 1, Math.max(0, x + dx));
            const idx = rowOffset + sx * 4;
            r += pixels[idx];
            g += pixels[idx + 1];
            b += pixels[idx + 2];
            count++;
          }
          const dstIdx = rowOffset + x * 4;
          temp[dstIdx] = r / count;
          temp[dstIdx + 1] = g / count;
          temp[dstIdx + 2] = b / count;
          temp[dstIdx + 3] = pixels[dstIdx + 3];
        }
      }

      // Vertical blur: temp -> pixels
      for (let x = 0; x < width; x++) {
        const colOffset = x * 4;
        for (let y = 0; y < height; y++) {
          let r = 0,
            g = 0,
            b = 0,
            count = 0;
          for (let dy = -radius; dy <= radius; dy++) {
            const sy = Math.min(height - 1, Math.max(0, y + dy));
            const idx = sy * width * 4 + colOffset;
            r += temp[idx];
            g += temp[idx + 1];
            b += temp[idx + 2];
            count++;
          }
          const dstIdx = y * width * 4 + colOffset;
          pixels[dstIdx] = r / count;
          pixels[dstIdx + 1] = g / count;
          pixels[dstIdx + 2] = b / count;
          pixels[dstIdx + 3] = temp[dstIdx + 3];
        }
      }
    }

    bloomCtx.putImageData(blurData, 0, 0);
    // Enhanced blend with multiple layers
    sceneCtx.globalCompositeOperation = "screen";

    // Outer bloom layer
    sceneCtx.globalAlpha = intensity * 0.3;
    sceneCtx.drawImage(bloomCanvas, 0, 0);

    // Inner bloom layer with slight offset for depth
    sceneCtx.globalAlpha = intensity * 0.2;
    sceneCtx.drawImage(bloomCanvas, 0, 0);

    sceneCtx.globalAlpha = 1;
    sceneCtx.globalCompositeOperation = "source-over";
  },

  applyChromaticAberration() {
    const baseOffset = state.chromaticAberration * 8;
    const audioBoost = 1 + (state.bassAvg / 255) * 0.6;
    const offset = baseOffset * audioBoost;

    // Enhanced chromatic aberration with better color separation
    sceneCtx.save();

    // Red channel (shifted left)
    sceneCtx.globalCompositeOperation = "screen";
    sceneCtx.globalAlpha = 0.35;
    sceneCtx.filter = "brightness(1.1) contrast(1.05)";
    sceneCtx.drawImage(postProcessCanvas, -offset * 1.2, 0);

    // Green channel (center, slightly enhanced)
    sceneCtx.globalAlpha = 0.36;
    sceneCtx.filter = "brightness(1.05)";
    sceneCtx.drawImage(postProcessCanvas, 0, 0);

    // Blue channel (shifted right)
    sceneCtx.globalAlpha = 0.35;
    sceneCtx.filter = "brightness(1.1) contrast(1.05)";
    sceneCtx.drawImage(postProcessCanvas, offset * 1.2, 0);

    // Add subtle vertical offset for more dynamic effect
    sceneCtx.globalAlpha = 0.1;
    sceneCtx.drawImage(postProcessCanvas, -offset * 0.5, -offset * 0.3);
    sceneCtx.drawImage(postProcessCanvas, offset * 0.5, offset * 0.3);

    sceneCtx.restore();
    sceneCtx.globalAlpha = 1;
    sceneCtx.globalCompositeOperation = "source-over";
  },

  applyVolumetricFog() {
    const fogGrad = sceneCtx.createLinearGradient(0, 0, 0, CONFIG.SCENE_HEIGHT);
    const fogColor = `rgba(${25 + state.midAvg / 10}, ${15 + state.bassAvg / 15}, ${35 + state.highAvg / 10}, ${state.fogDensity * (1 + (state.bassAvg / 255) * 0.3)})`;
    fogGrad.addColorStop(0, "transparent");
    fogGrad.addColorStop(0.5, fogColor);
    fogGrad.addColorStop(1, fogColor);

    sceneCtx.fillStyle = fogGrad;
    sceneCtx.fillRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
  },

  renderSky() {
    const grad = sceneCtx.createLinearGradient(0, 0, 0, 250);
    const bassBoost = (state.bassAvg / 255) * 0.15 * state.reactivity;
    grad.addColorStop(0, `rgb(${10 + bassBoost * 50}, 5, ${15 + (state.highAvg / 255) * 10})`);
    grad.addColorStop(1, `rgb(${25 + (state.midAvg / 255) * 20}, 8, 35)`);
    sceneCtx.fillStyle = grad;
    sceneCtx.fillRect(0, 0, CONFIG.SCENE_WIDTH, 250);

    // Stars
    sceneCtx.fillStyle = "#fff";
    for (let i = 0; i < 60; i++) {
      const twinkle = (Math.sin(state.t * 0.03 + i * 0.5) + 1) / 2;
      const audioTwinkle = 1 + (state.highAvg / 255) * 0.5 * state.reactivity;
      sceneCtx.globalAlpha = twinkle * 0.7 * audioTwinkle;
      sceneCtx.fillRect((i * 97) % CONFIG.SCENE_WIDTH, (i * 43) % 200, 1.5, 1.5);
    }
    sceneCtx.globalAlpha = 1;

    // Clouds (simplified)
    sceneCtx.fillStyle = "rgba(40, 20, 50, 0.12)";
    for (let i = 0; i < 4; i++) {
      const cx = ((state.t * 0.2 + i * 200) % (CONFIG.SCENE_WIDTH + 200)) - 100;
      sceneCtx.beginPath();
      sceneCtx.ellipse(cx, 80 + i * 30, 80, 25, 0, 0, Math.PI * 2);
      sceneCtx.fill();
    }
  },

  renderBuildings() {
    entities.buildings.forEach((b, bi) => {
      const pulse = 1 + Math.sin(state.t * 0.02 + b.pulsePhase) * 0.02 * (state.bassAvg / 255);
      const h = b.h * pulse;
      const y = CONFIG.SCENE_HEIGHT - h;

      const gradient = sceneCtx.createLinearGradient(b.x, y, b.x + b.w, y);
      gradient.addColorStop(0, `rgb(${25 + bi * 2}, ${20 + bi * 2}, ${35 + bi * 2})`);
      gradient.addColorStop(1, `rgb(${35 + bi * 2}, ${30 + bi * 2}, ${45 + bi * 2})`);
      sceneCtx.fillStyle = gradient;
      sceneCtx.fillRect(b.x, y, b.w, h);

      // Windows (simplified render)
      b.windows.forEach((w) => {
        if (!w.lit) {
          return;
        }
        const brightness = w.flicker && Math.random() < 0.1 ? 0.3 : 0.8;
        const audioBoost = 1 + (state.midAvg / 255) * 0.5 * state.reactivity;
        sceneCtx.fillStyle = `hsla(${w.hue}, 80%, ${50 * brightness * audioBoost}%, ${0.7 + (state.midAvg / 255) * 0.3})`;
        sceneCtx.fillRect(w.x, w.y + (CONFIG.SCENE_HEIGHT - h - b.baseY), 8, 10);
      });

      // Enhanced neon signs with multi-layer glow
      if (b.sign) {
        const signY = y + b.sign.y;
        const flicker = Math.sin(state.t * 0.3 + bi) > -0.9 ? 1 : 0.3;
        const audioGlow = 1 + (state.highAvg / 255) * 0.8 * state.reactivity;
        const baseGlow = 20 * flicker * audioGlow * state.glowAmount;

        sceneCtx.font = "bold 18px sans-serif";

        // Outer glow layer
        sceneCtx.shadowColor = b.sign.color;
        sceneCtx.shadowBlur = baseGlow * 2;
        sceneCtx.fillStyle = b.sign.color;
        sceneCtx.fillText(b.sign.text, b.x + 5, signY);

        // Middle glow layer
        sceneCtx.shadowBlur = baseGlow * 1.5;
        sceneCtx.fillText(b.sign.text, b.x + 5, signY);

        // Inner glow layer
        sceneCtx.shadowBlur = baseGlow;
        sceneCtx.fillText(b.sign.text, b.x + 5, signY);

        // Core text
        sceneCtx.shadowBlur = 0;
        sceneCtx.fillStyle = "#ffffff";
        sceneCtx.globalAlpha = 0.9;
        sceneCtx.fillText(b.sign.text, b.x + 5, signY);
        sceneCtx.globalAlpha = 1;

        // Pulsing effect on beat
        if (state.beatDetected) {
          sceneCtx.shadowColor = b.sign.color;
          sceneCtx.shadowBlur = baseGlow * 2.5;
          sceneCtx.fillStyle = b.sign.color;
          sceneCtx.fillText(b.sign.text, b.x + 5, signY);
        }
        sceneCtx.shadowBlur = 0;
      }
    });
  },

  renderGround() {
    // Road
    sceneCtx.fillStyle = "#151515";
    sceneCtx.fillRect(0, 360, CONFIG.SCENE_WIDTH, 90);

    // Enhanced wet road reflection with screen space reflections
    const reflectionGrad = sceneCtx.createLinearGradient(0, 360, 0, 450);
    const reflectionIntensity = 0.2 + (state.midAvg / 255) * 0.15 * state.reactivity;
    reflectionGrad.addColorStop(0, `rgba(0, 80, 120, ${0.25 * reflectionIntensity})`);
    reflectionGrad.addColorStop(0.5, `rgba(0, 50, 80, ${0.15 * reflectionIntensity})`);
    reflectionGrad.addColorStop(1, "rgba(0, 20, 40, 0.05)");
    sceneCtx.fillStyle = reflectionGrad;
    sceneCtx.fillRect(0, 360, CONFIG.SCENE_WIDTH, 90);

    // Add reflection of neon signs
    if (state.rainIntensity > 0.3) {
      sceneCtx.save();
      sceneCtx.globalCompositeOperation = "screen";
      sceneCtx.globalAlpha = 0.3 * reflectionIntensity;
      sceneCtx.scale(1, -1);
      sceneCtx.translate(0, -CONFIG.SCENE_HEIGHT * 2);

      // Reflect neon signs
      entities.buildings.forEach((b, bi) => {
        if (b.sign) {
          const signY = CONFIG.SCENE_HEIGHT - b.h + b.sign.y;
          const flicker = Math.sin(state.t * 0.3 + bi) > -0.9 ? 1 : 0.3;
          const audioGlow = 1 + (state.highAvg / 255) * 0.5 * state.reactivity;

          sceneCtx.font = "bold 16px sans-serif";
          sceneCtx.fillStyle = b.sign.color;
          sceneCtx.shadowColor = b.sign.color;
          sceneCtx.shadowBlur = 10 * flicker * audioGlow * state.glowAmount;
          sceneCtx.fillText(b.sign.text, b.x + 5, signY);
        }
      });

      sceneCtx.restore();
    }

    // Lane markings
    sceneCtx.strokeStyle = `rgba(255, 200, 0, ${0.5 + (state.bassAvg / 255) * 0.5 * state.reactivity})`;
    sceneCtx.lineWidth = 2;
    sceneCtx.setLineDash([25, 15]);
    [385, 405, 425].forEach((y) => {
      sceneCtx.beginPath();
      sceneCtx.moveTo(0, y);
      sceneCtx.lineTo(CONFIG.SCENE_WIDTH, y);
      sceneCtx.stroke();
    });
    sceneCtx.setLineDash([]);

    // Sidewalk
    sceneCtx.fillStyle = "#252525";
    sceneCtx.fillRect(0, 315, CONFIG.SCENE_WIDTH, 45);
    sceneCtx.fillStyle = "#333";
    sceneCtx.fillRect(0, 358, CONFIG.SCENE_WIDTH, 4);

    // Crosswalk
    sceneCtx.fillStyle = `rgba(255, 255, 255, ${0.7 + (state.bassAvg / 255) * 0.3})`;
    for (let i = 0; i < 8; i++) {
      sceneCtx.fillRect(380 + i * 10, 360, 6, 40);
    }

    // Enhanced streetlights with volumetric lighting
    const lightPositions = [80, 200, 350, 500, 650, 750];
    lightPositions.forEach((lx, i) => {
      // Pole
      sceneCtx.fillStyle = "#333";
      sceneCtx.fillRect(lx - 2, 280, 4, 80);
      sceneCtx.fillRect(lx - 2, 280, 20, 3);

      const flicker = Math.sin(state.t * 0.1 + i * 2) > -0.95 ? 1 : 0.5;
      const audioBoost = 1 + (state.midAvg / 255) * 0.4 * state.reactivity;
      const glowSize = 25 * flicker * state.glowAmount * audioBoost;

      // Volumetric light cone
      const lightGrad = sceneCtx.createRadialGradient(lx + 15, 282, 0, lx + 15, 282, glowSize * 2);
      lightGrad.addColorStop(0, `rgba(255, 200, 100, ${0.6 * flicker * audioBoost})`);
      lightGrad.addColorStop(0.5, `rgba(255, 200, 100, ${0.3 * flicker * audioBoost})`);
      lightGrad.addColorStop(1, "transparent");
      sceneCtx.fillStyle = lightGrad;
      sceneCtx.beginPath();
      sceneCtx.arc(lx + 15, 282, glowSize * 2, 0, Math.PI * 2);
      sceneCtx.fill();

      // Light bulb
      sceneCtx.fillStyle = `rgba(255, 220, 120, ${0.95 * flicker * audioBoost})`;
      sceneCtx.shadowColor = "#ffcc66";
      sceneCtx.shadowBlur = glowSize;
      sceneCtx.beginPath();
      sceneCtx.arc(lx + 15, 282, 6, 0, Math.PI * 2);
      sceneCtx.fill();

      // Core
      sceneCtx.shadowBlur = 0;
      sceneCtx.fillStyle = "#ffffcc";
      sceneCtx.beginPath();
      sceneCtx.arc(lx + 15, 282, 3, 0, Math.PI * 2);
      sceneCtx.fill();
    });
  },

  renderCars() {
    const sorted = [...entities.cars].sort((a, b) => a.y - b.y);

    sorted.forEach((car) => {
      // Shadow
      sceneCtx.fillStyle = "rgba(0, 0, 0, 0.2)";
      sceneCtx.fillRect(car.x, car.y + car.h + 2, car.w, 5);

      // Body
      sceneCtx.fillStyle = car.color;
      sceneCtx.fillRect(car.x, car.y, car.w, car.h);
      sceneCtx.fillRect(car.x + car.w * 0.2, car.y - car.h * 0.4, car.w * 0.5, car.h * 0.4);

      // Windows
      sceneCtx.fillStyle = "rgba(100, 150, 200, 0.3)";
      sceneCtx.fillRect(car.x + car.w * 0.22, car.y - car.h * 0.35, car.w * 0.2, car.h * 0.35);
      sceneCtx.fillRect(car.x + car.w * 0.45, car.y - car.h * 0.35, car.w * 0.2, car.h * 0.35);

      // Headlights
      const headlightX = car.dir > 0 ? car.x + car.w - 5 : car.x + 5;
      sceneCtx.fillStyle = "rgba(255, 255, 200, 0.9)";
      sceneCtx.beginPath();
      sceneCtx.arc(headlightX, car.y + car.h * 0.3, 3, 0, Math.PI * 2);
      sceneCtx.arc(headlightX, car.y + car.h * 0.7, 3, 0, Math.PI * 2);
      sceneCtx.fill();

      // Taillights
      const tailX = car.dir > 0 ? car.x + 3 : car.x + car.w - 8;
      const tailBright = car.braking ? 1 : 0.6;
      sceneCtx.fillStyle = `rgba(255, 0, 0, ${tailBright})`;
      sceneCtx.fillRect(tailX, car.y + 3, 5, 5);
      sceneCtx.fillRect(tailX, car.y + car.h - 8, 5, 5);

      // Wheels
      sceneCtx.fillStyle = "#0a0a0a";
      sceneCtx.beginPath();
      sceneCtx.arc(car.x + 12, car.y + car.h, 6, 0, Math.PI * 2);
      sceneCtx.arc(car.x + car.w - 12, car.y + car.h, 6, 0, Math.PI * 2);
      sceneCtx.fill();
    });
  },

  renderPeople() {
    entities.people.forEach((p) => {
      const bounce =
        Math.sin(state.t * 0.15 + p.phase) * 4 * (state.bassAvg / 255) * state.reactivity;
      const sway = p.behavior === "dance" ? Math.sin(state.t * 0.1 + p.phase) * 3 : 0;

      const x = p.x + sway;
      const y = p.y + bounce;
      const h = p.height;

      // Shadow
      sceneCtx.fillStyle = "rgba(0, 0, 0, 0.3)";
      sceneCtx.beginPath();
      sceneCtx.ellipse(x, p.y + 5, 8, 3, 0, 0, Math.PI * 2);
      sceneCtx.fill();

      // Body
      sceneCtx.fillStyle = p.clothesColor;
      sceneCtx.fillRect(x - 5, y - h * 0.6, 10, h * 0.4);

      // Head
      sceneCtx.fillStyle = "#ddb892";
      sceneCtx.beginPath();
      sceneCtx.arc(x, y - h * 0.75, 6, 0, Math.PI * 2);
      sceneCtx.fill();

      // Hair
      sceneCtx.fillStyle = p.hairColor;
      sceneCtx.beginPath();
      sceneCtx.arc(x, y - h * 0.8, 6, Math.PI, Math.PI * 2);
      sceneCtx.fill();

      // Umbrella
      if (p.umbrella) {
        sceneCtx.fillStyle = p.umbrellaColor;
        sceneCtx.beginPath();
        sceneCtx.arc(x, y - h - 15, 18, Math.PI, Math.PI * 2);
        sceneCtx.fill();
      }
    });
  },

  renderRain() {
    if (state.rainIntensity <= 0) {
      return;
    }

            const audioScale = 1 + smoothedValue * 0.3 * state.reactivity;

            if (isFullscreenMode) {
                imgObj.baseX = CONFIG.SCENE_WIDTH / 2;
                imgObj.baseY = CONFIG.SCENE_HEIGHT / 2;
            }

            // Skip automatic movement for character when being controlled
            const isCharacterControlled = imgObj.isCharacter && (state.keys['w'] || state.keys['s'] || state.keys['a'] || state.keys['d'] ||
                state.keys['arrowup'] || state.keys['arrowdown'] || state.keys['arrowleft'] || state.keys['arrowright']);

            if (!isCharacterControlled) {
                // Apply movement mode
                this.applyMovement(imgObj, i, isFullscreenMode);
            }

            // Apply audio targets
            if (map.targets.scale) imgObj.scale *= audioScale;
            if (map.targets.rotation) imgObj.rotation += smoothedValue * 0.1;
            if (map.targets.x && !isCharacterControlled) imgObj.x += (smoothedValue - 0.5) * (isFullscreenMode ? 200 : 100);
            if (map.targets.y && !isCharacterControlled) imgObj.y += (smoothedValue - 0.5) * (isFullscreenMode ? 200 : 100);
            if (map.targets.alpha) {
                imgObj.alpha = 0.3 + smoothedValue * 0.7;
            } else {
                imgObj.alpha = 0.7 + (state.midAvg / 255) * 0.3 * state.reactivity;
            }
            if (map.targets.hue) {
                imgObj.hueShift = smoothedValue * 360;
            } else {
                imgObj.hueShift = 0;
            }

            if (state.beatDetected) imgObj.scale *= 1.15;
        });
    },

    applyMovement(imgObj, index, isFullscreenMode) {
        const t = state.t;
        const scale = state.imageScale;

        switch(state.imageMoveMode) {
            case 'float':
                imgObj.x = imgObj.baseX + Math.sin(t * 0.02 + imgObj.phase) * (isFullscreenMode ? 50 : 30);
                imgObj.y = imgObj.baseY + Math.cos(t * 0.015 + imgObj.phase) * (isFullscreenMode ? 30 : 20);
                imgObj.scale = scale * (0.9 + Math.sin(t * 0.03 + imgObj.phase) * 0.1);
                break;
            case 'bounce':
                const bounce = Math.max(0, state.bassAvg / 255 - 0.3) * (isFullscreenMode ? 50 : 100) * state.reactivity;
                imgObj.x = imgObj.baseX;
                imgObj.y = imgObj.baseY - bounce;
                imgObj.scale = scale;
                break;
            case 'orbit':
                const angle = t * imgObj.orbitSpeed + imgObj.phase;
                const radius = isFullscreenMode ? imgObj.orbitRadius * 0.5 : imgObj.orbitRadius;
                imgObj.x = imgObj.baseX + Math.cos(angle) * radius;
                imgObj.y = imgObj.baseY + Math.sin(angle) * radius;
                imgObj.scale = scale;
                imgObj.rotation = isFullscreenMode ? 0 : angle;
                break;
            case 'wave':
                imgObj.x = imgObj.baseX + Math.sin(t * 0.03 + index * 0.5) * (isFullscreenMode ? 100 : 80);
                imgObj.y = imgObj.baseY + Math.sin(t * 0.02 + index * 0.3) * 60;
                imgObj.scale = scale * (1 + Math.sin(t * 0.04 + index) * 0.2);
                imgObj.rotation = isFullscreenMode ? 0 : Math.sin(t * 0.02 + index) * 0.3;
                break;
            case 'spin':
                imgObj.x = imgObj.baseX;
                imgObj.y = imgObj.baseY;
                imgObj.rotation += 0.02;
                imgObj.scale = scale;
                break;
            case 'pulse':
                imgObj.x = imgObj.baseX;
                imgObj.y = imgObj.baseY;
                imgObj.scale = scale * (0.8 + Math.sin(t * 0.1) * 0.2);
                break;
        }
    },

    render() {
        if (entities.images.length === 0) return;

        switch(state.imageDisplayMode) {
            case 'fullscreen': this.renderFullscreen(); break;
            case 'tiled': this.renderTiled(); break;
            default: this.renderFloating(); break;
        }
    },

    renderFullscreen() {
        entities.images.forEach(imgObj => {
            sceneCtx.save();
            this.applyBlendMode(imgObj.blendMode);
            sceneCtx.globalAlpha = imgObj.alpha;

            // Enhanced image rendering quality
            sceneCtx.imageSmoothingEnabled = true;
            sceneCtx.imageSmoothingQuality = 'high';

            const centerX = CONFIG.SCENE_WIDTH / 2;
            const centerY = CONFIG.SCENE_HEIGHT / 2;
            sceneCtx.translate(centerX, centerY);
            sceneCtx.rotate(imgObj.rotation);

            if (imgObj.hueShift !== 0) sceneCtx.filter = `hue-rotate(${imgObj.hueShift}deg)`;

            const imgAspect = imgObj.img.width / imgObj.img.height;
            const screenAspect = CONFIG.SCENE_WIDTH / CONFIG.SCENE_HEIGHT;

            let drawW, drawH;
            if (imgAspect > screenAspect) {
                drawH = CONFIG.SCENE_HEIGHT * imgObj.scale;
                drawW = drawH * imgAspect;
            } else {
                drawW = CONFIG.SCENE_WIDTH * imgObj.scale;
                drawH = drawW / imgAspect;
            }

            const offsetX = imgObj.x - imgObj.baseX;
            const offsetY = imgObj.y - imgObj.baseY;

            sceneCtx.drawImage(imgObj.img, -drawW / 2 + offsetX, -drawH / 2 + offsetY, drawW, drawH);
            sceneCtx.filter = 'none';

            if (state.beatDetected && state.glowAmount > 0.5) {
                sceneCtx.shadowColor = CONFIG.PALETTE.primary;
                sceneCtx.shadowBlur = 40;
                sceneCtx.drawImage(imgObj.img, -drawW / 2 + offsetX, -drawH / 2 + offsetY, drawW, drawH);
                sceneCtx.shadowBlur = 0;
            }

            sceneCtx.restore();
        });
    },

    renderTiled() {
        entities.images.forEach(imgObj => {
            sceneCtx.save();
            this.applyBlendMode(imgObj.blendMode);
            sceneCtx.globalAlpha = imgObj.alpha;

            // Enhanced image rendering quality
            sceneCtx.imageSmoothingEnabled = true;
            sceneCtx.imageSmoothingQuality = 'high';

            if (imgObj.hueShift !== 0) sceneCtx.filter = `hue-rotate(${imgObj.hueShift}deg)`;

            const baseTileSize = 150;
            const tileW = baseTileSize * imgObj.scale;
            const tileH = tileW * (imgObj.img.height / imgObj.img.width);

            const offsetX = (imgObj.x - imgObj.baseX) % tileW;
            const offsetY = (imgObj.y - imgObj.baseY) % tileH;

            const numX = Math.ceil(CONFIG.SCENE_WIDTH / tileW) + 2;
            const numY = Math.ceil(CONFIG.SCENE_HEIGHT / tileH) + 2;

            for (let ty = -1; ty < numY; ty++) {
                for (let tx = -1; tx < numX; tx++) {
                    const x = tx * tileW + offsetX;
                    const y = ty * tileH + offsetY;

                    sceneCtx.save();
                    sceneCtx.translate(x + tileW / 2, y + tileH / 2);
                    sceneCtx.rotate(imgObj.rotation);
                    sceneCtx.drawImage(imgObj.img, -tileW / 2, -tileH / 2, tileW, tileH);
                    sceneCtx.restore();
                }
            }

            sceneCtx.filter = 'none';
            sceneCtx.restore();
        });
    },

    renderFloating() {
        entities.images.forEach(imgObj => {
            sceneCtx.save();
            this.applyBlendMode(imgObj.blendMode);
            sceneCtx.globalAlpha = imgObj.alpha;

            // Enhanced image rendering quality
            sceneCtx.imageSmoothingEnabled = true;
            sceneCtx.imageSmoothingQuality = 'high';

            sceneCtx.translate(imgObj.x, imgObj.y);
            sceneCtx.rotate(imgObj.rotation);
            sceneCtx.scale(imgObj.scale, imgObj.scale);

            if (imgObj.hueShift !== 0) sceneCtx.filter = `hue-rotate(${imgObj.hueShift}deg)`;

            const aspectRatio = imgObj.img.width / imgObj.img.height;
            const maxSize = 200;
            const drawW = aspectRatio > 1 ? maxSize : maxSize * aspectRatio;
            const drawH = aspectRatio > 1 ? maxSize / aspectRatio : maxSize;

            sceneCtx.drawImage(imgObj.img, -drawW / 2, -drawH / 2, drawW, drawH);
            sceneCtx.filter = 'none';

            // Enhanced glow on beat
            if (state.beatDetected && state.glowAmount > 0.5) {
                const glowIntensity = 1 + state.bassAvg / 255 * 0.5;

                // Outer glow
                sceneCtx.shadowColor = CONFIG.PALETTE.primary;
                sceneCtx.shadowBlur = 50 * glowIntensity;
                sceneCtx.globalAlpha = 0.6;
                sceneCtx.drawImage(imgObj.img, -drawW / 2, -drawH / 2, drawW, drawH);

                // Middle glow
                sceneCtx.shadowBlur = 30 * glowIntensity;
                sceneCtx.globalAlpha = 0.8;
                sceneCtx.drawImage(imgObj.img, -drawW / 2, -drawH / 2, drawW, drawH);

                // Core
                sceneCtx.shadowBlur = 0;
                sceneCtx.globalAlpha = 1;
            }

            // Character indicator (pulsing glow)
            if (imgObj.isCharacter) {
                const pulse = 1 + Math.sin(state.t * 0.1) * 0.1;
                sceneCtx.shadowColor = CONFIG.PALETTE.highlight;
                sceneCtx.shadowBlur = 30 * pulse;
                sceneCtx.globalAlpha = 0.7 * pulse;
                sceneCtx.drawImage(imgObj.img, -drawW / 2, -drawH / 2, drawW, drawH);
                sceneCtx.shadowBlur = 0;
                sceneCtx.globalAlpha = 1;

                // Character control indicator
                if (state.characterVelocity.x !== 0 || state.characterVelocity.y !== 0) {
                    sceneCtx.strokeStyle = CONFIG.PALETTE.highlight;
                    sceneCtx.lineWidth = 2;
                    sceneCtx.setLineDash([3, 3]);
                    sceneCtx.strokeRect(-drawW / 2 - 8, -drawH / 2 - 8, drawW + 16, drawH + 16);
                    sceneCtx.setLineDash([]);
                }
            }

            // Outlines
            if (imgObj === state.selectedImage) {
                sceneCtx.globalAlpha = 1;
                sceneCtx.strokeStyle = CONFIG.PALETTE.secondary;
                sceneCtx.lineWidth = 3;
                sceneCtx.setLineDash([5, 5]);
                sceneCtx.strokeRect(-drawW / 2 - 5, -drawH / 2 - 5, drawW + 10, drawH + 10);
                sceneCtx.setLineDash([]);
            }

            if (state.isDragging && imgObj === state.draggedImage) {
                sceneCtx.globalAlpha = 1;
                sceneCtx.strokeStyle = CONFIG.PALETTE.accent;
                sceneCtx.lineWidth = 2;
                sceneCtx.strokeRect(-drawW / 2 - 3, -drawH / 2 - 3, drawW + 6, drawH + 6);
            }

            sceneCtx.restore();
        });
    },

    applyBlendMode(mode) {
        switch(mode) {
            case 'screen': sceneCtx.globalCompositeOperation = 'screen'; break;
            case 'multiply': sceneCtx.globalCompositeOperation = 'multiply'; break;
            case 'overlay': sceneCtx.globalCompositeOperation = 'overlay'; break;
            default: sceneCtx.globalCompositeOperation = 'source-over'; break;
        }
    }
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SCENE RENDERING (Simplified - buildings, people, cars, rain, etc.)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const scene = {
    init() {
        // Initialize buildings, people, cars, rain
        this.initBuildings();
        this.initPeople();
        this.initCars();
        this.initRain();
    },

    initBuildings() {
        const specs = [
            { x: 0, w: 70, h: 200, sign: null },
            { x: 80, w: 55, h: 290, sign: { text: '„Éõ„ÉÜ„É´', color: '#ff00ff', y: 80 } },
            { x: 145, w: 95, h: 175, sign: { text: 'ÈÖíÂ†¥', color: '#ff6b00', y: 100 } },
            { x: 250, w: 65, h: 330, spire: true },
            { x: 325, w: 100, h: 160, sign: { text: 'CLUB', color: '#00f5ff', y: 90 } },
            { x: 435, w: 60, h: 270, sign: { text: '24H', color: '#39ff14', y: 120 } },
            { x: 505, w: 85, h: 195 },
            { x: 600, w: 70, h: 250, sign: { text: 'BAR', color: '#ff0055', y: 140 } },
            { x: 680, w: 60, h: 180 },
            { x: 750, w: 50, h: 220 }
        ];

        specs.forEach((s, i) => {
            const windowRows = Math.floor(s.h / 14);
            const windowCols = Math.floor(s.w / 14);
            const windows = [];

            for (let r = 0; r < windowRows; r++) {
                for (let c = 0; c < windowCols; c++) {
                    windows.push({
                        x: s.x + 5 + c * 13,
                        y: CONFIG.SCENE_HEIGHT - s.h + 8 + r * 14,
                        lit: Math.random() > 0.3,
                        flicker: Math.random() < 0.05,
                        hue: Math.random() * 30 + 30
                    });
                }
            }

            entities.buildings.push({
                ...s,
                windows,
                baseY: CONFIG.SCENE_HEIGHT - s.h,
                pulsePhase: Math.random() * Math.PI * 2
            });
        });
    },

    initPeople() {
        const hairColors = ['#111', '#222', '#331100', '#ff00ff', '#00f5ff'];
        const clothesColors = ['#111', '#222', '#333', '#ff0055', '#00f5ff', '#ff00ff', '#006633'];

        for (let i = 0; i < 40; i++) {
            const hasUmbrella = Math.random() < 0.4;
            entities.people.push({
                x: Math.random() * CONFIG.SCENE_WIDTH,
                y: 320 + Math.random() * 35,
                vx: (Math.random() - 0.5) * 1.5,
                height: 28 + Math.random() * 15,
                behavior: Math.random() < 0.6 ? 'walk' : Math.random() < 0.5 ? 'stand' : 'dance',
                phase: Math.random() * Math.PI * 2,
                hairColor: hairColors[Math.floor(Math.random() * hairColors.length)],
                clothesColor: clothesColors[Math.floor(Math.random() * clothesColors.length)],
                umbrella: hasUmbrella,
                umbrellaColor: hasUmbrella ? CONFIG.PALETTE.neon[Math.floor(Math.random() * CONFIG.PALETTE.neon.length)] : null,
                armUp: false
            });
        }
    },

    initCars() {
        const lanes = [
            { y: 375, dir: 1, speed: 2.5 },
            { y: 395, dir: 1, speed: 3.5 },
            { y: 415, dir: -1, speed: 3 },
            { y: 435, dir: -1, speed: 4 }
        ];

        const types = [
            { name: 'sedan', w: 55, h: 22, weight: 0.35 },
            { name: 'sports', w: 60, h: 18, weight: 0.15 },
            { name: 'suv', w: 65, h: 28, weight: 0.2 },
            { name: 'taxi', w: 55, h: 22, weight: 0.2, color: '#ccaa00' },
            { name: 'police', w: 58, h: 24, weight: 0.1, lights: true, color: '#111' }
        ];

        const colors = ['#1a1a1a', '#2a2a2a', '#0a0a0a', '#330000', '#000033', '#003300'];

        for (let i = 0; i < 16; i++) {
            const lane = lanes[i % lanes.length];
            const type = utils.weightedRandom(types);

            entities.cars.push({
                x: Math.random() * CONFIG.SCENE_WIDTH * 1.5 - CONFIG.SCENE_WIDTH * 0.25,
                y: lane.y,
                w: type.w,
                h: type.h,
                dir: lane.dir,
                speed: lane.speed * (0.8 + Math.random() * 0.4),
                color: type.color || colors[Math.floor(Math.random() * colors.length)],
                hasLights: type.lights || false,
                lightPhase: Math.random() * Math.PI * 2,
                braking: false
            });
        }
    },

    initRain() {
        for (let i = 0; i < 200; i++) {
            const drop = pools.get('raindrops') || {};
            drop.x = Math.random() * CONFIG.SCENE_WIDTH;
            drop.y = Math.random() * CONFIG.SCENE_HEIGHT;
            drop.speed = 8 + Math.random() * 6;
            drop.length = 10 + Math.random() * 15;
            entities.raindrops.push(drop);
        }
    },

    update() {
        this.updatePeople();
        this.updateCars();
        this.updateRain();
        this.updateParticles();
    },

    updatePeople() {
        entities.people.forEach(p => {
            if (p.behavior === 'walk') {
                p.x += p.vx * (1 + state.bassAvg / 255 * 0.3 * state.reactivity);
                if (p.x < -30) p.x = CONFIG.SCENE_WIDTH + 30;
                if (p.x > CONFIG.SCENE_WIDTH + 30) p.x = -30;
            } else if (p.behavior === 'dance') {
                p.x += Math.sin(state.t * 0.1 + p.phase) * 0.5;
            }

            if (state.beatDetected && Math.random() < 0.3) {
                p.armUp = true;
                setTimeout(() => p.armUp = false, 300);
            }
        });
    },

    updateCars() {
        entities.cars.forEach(car => {
            const speedMod = 1 + (state.bassAvg / 255) * 0.5 * state.reactivity;
            car.x += car.speed * car.dir * speedMod;

            if (car.dir > 0 && car.x > CONFIG.SCENE_WIDTH + 100) car.x = -car.w - 50;
            if (car.dir < 0 && car.x < -car.w - 50) car.x = CONFIG.SCENE_WIDTH + 100;

            if (Math.random() < 0.002) {
                car.braking = true;
                setTimeout(() => car.braking = false, 500);
            }
        });
    },

    updateRain() {
        if (state.rainIntensity <= 0) return;

        entities.raindrops.forEach(drop => {
            drop.x += 2 * state.rainIntensity;
            drop.y += drop.speed * state.rainIntensity;

            if (drop.y > 360) {
                if (Math.random() < 0.3) {
                    const splash = pools.get('splashes') || {};
                    splash.x = drop.x;
                    splash.y = 360 + Math.random() * 20;
                    splash.radius = 2;
                    splash.maxRadius = 5 + Math.random() * 3;
                    splash.alpha = 0.6;
                    entities.splashes.push(splash);
                }
                drop.x = Math.random() * CONFIG.SCENE_WIDTH;
                drop.y = -drop.length;
            }
        });

        for (let i = entities.splashes.length - 1; i >= 0; i--) {
            const splash = entities.splashes[i];
            splash.radius += 0.5;
            splash.alpha -= 0.08;
            if (splash.alpha <= 0) {
                pools.release('splashes', splash);
                entities.splashes.splice(i, 1);
            }
        }
    },

    updateParticles() {
        // Steam
        if (Math.random() < 0.1) {
            const spawnPoints = [100, 300, 500, 700];
            const x = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            entities.steamParticles.push({
                x: x + Math.random() * 20 - 10,
                y: 360,
                size: 10 + Math.random() * 20,
                alpha: 0.15,
                vy: -0.5 - Math.random() * 0.5
            });
        }

        for (let i = entities.steamParticles.length - 1; i >= 0; i--) {
            const p = entities.steamParticles[i];
            p.y += p.vy;
            p.x += Math.sin(state.t * 0.05 + i) * 0.3;
            p.size += 0.2;
            p.alpha -= 0.002;
            if (p.alpha <= 0 || p.y < 200) {
                pools.release('steam', p);
                entities.steamParticles.splice(i, 1);
            }
        }

        // Enhanced sparks with more variety
        if (state.beatDetected && Math.random() < 0.4) {
            const x = 100 + Math.random() * 600;
            const count = 15 + Math.floor(state.bassAvg / 20);
            for (let i = 0; i < count; i++) {
                const spark = pools.get('sparks') || {};
                spark.x = x + (Math.random() - 0.5) * 20;
                spark.y = 100 + Math.random() * 50;
                spark.vx = (Math.random() - 0.5) * 6;
                spark.vy = -Math.random() * 4 - 1;
                spark.life = 1;
                spark.prevX = spark.x;
                spark.prevY = spark.y;
                entities.sparks.push(spark);
            }
        }

        for (let i = entities.sparks.length - 1; i >= 0; i--) {
            const s = entities.sparks[i];
            s.x += s.vx;
            s.y += s.vy;
            s.vy += 0.2;
            s.vx *= 0.98; // Air resistance
            s.life -= 0.04;
            if (s.life <= 0 || s.y > CONFIG.SCENE_HEIGHT + 50) {
                pools.release('sparks', s);
                entities.sparks.splice(i, 1);
            }
        }
    },

    render() {
        // Save previous frame for motion blur
        if (state.motionBlur > 0 && previousFrameCtx) {
            previousFrameCtx.clearRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
            previousFrameCtx.drawImage(sceneCanvas, 0, 0);
        }

        sceneCtx.clearRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);

        this.renderSky();
        this.renderBuildings();
        this.renderGround();
        this.renderParticles();
        this.renderCars();
        this.renderPeople();
        this.renderRain();

        // Apply post-processing
        this.applyPostProcessing();
    },

    applyPostProcessing() {
        if (!postProcessCtx) return;

        if (state.bloomIntensity > 0 || state.chromaticAberration > 0 || state.motionBlur > 0) {
            // Copy scene to post-process buffer
            postProcessCtx.clearRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
            postProcessCtx.drawImage(sceneCanvas, 0, 0);

            // Apply bloom
            if (state.bloomIntensity > 0) {
                this.applyBloom();
            }

            // Apply motion blur
            if (state.motionBlur > 0 && previousFrameCtx) {
                sceneCtx.globalAlpha = state.motionBlur * 0.3;
                sceneCtx.drawImage(previousFrameCanvas, 0, 0);
                sceneCtx.globalAlpha = 1;
            }

            // Apply chromatic aberration
            if (state.chromaticAberration > 0) {
                this.applyChromaticAberration();
            }
        }

        // Apply volumetric fog
        if (state.fogDensity > 0) {
            this.applyVolumetricFog();
        }
    },

    applyBloom() {
        const intensity = state.bloomIntensity * (1 + state.bassAvg / 255 * 0.4);

        if (!bloomCtx) return;

        // Enhanced bloom extraction with better threshold
        bloomCtx.clearRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
        bloomCtx.drawImage(postProcessCanvas, 0, 0);

        const imageData = bloomCtx.getImageData(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
        const data = imageData.data;
        const threshold = 120; // Lower threshold for more bloom

        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            // Use perceptual luminance for better results
            const brightness = r * 0.299 + g * 0.587 + b * 0.114;

            if (brightness > threshold) {
                // Enhanced bloom with smooth falloff
                const factor = Math.pow((brightness - threshold) / (255 - threshold), 1.5) * intensity;
                const boost = 1.0 + factor * 0.8;

                data[i] = Math.min(255, r * boost);
                data[i + 1] = Math.min(255, g * boost);
                data[i + 2] = Math.min(255, b * boost);
            } else {
                // Darken non-bloom areas more smoothly
                const darken = 0.92 + (brightness / threshold) * 0.08;
                data[i] *= darken;
                data[i + 1] *= darken;
                data[i + 2] *= darken;
            }
        }

        bloomCtx.putImageData(imageData, 0, 0);

        // Apply Gaussian blur simulation using a separable box blur
        const blurData = bloomCtx.getImageData(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
        const pixels = blurData.data;
        const width = CONFIG.SCENE_WIDTH;
        const height = CONFIG.SCENE_HEIGHT;
        const radius = 2;
        const temp = new Uint8ClampedArray(pixels.length);

        // Perform a small number of separable blur passes for a stronger effect
        for (let pass = 0; pass < 2; pass++) {
            // Horizontal blur: pixels -> temp
            for (let y = 0; y < height; y++) {
                const rowOffset = y * width * 4;
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, count = 0;
                    for (let dx = -radius; dx <= radius; dx++) {
                        const sx = Math.min(width - 1, Math.max(0, x + dx));
                        const idx = rowOffset + sx * 4;
                        r += pixels[idx];
                        g += pixels[idx + 1];
                        b += pixels[idx + 2];
                        count++;
                    }
                    const dstIdx = rowOffset + x * 4;
                    temp[dstIdx] = r / count;
                    temp[dstIdx + 1] = g / count;
                    temp[dstIdx + 2] = b / count;
                    temp[dstIdx + 3] = pixels[dstIdx + 3];
                }
            }

            // Vertical blur: temp -> pixels
            for (let x = 0; x < width; x++) {
                const colOffset = x * 4;
                for (let y = 0; y < height; y++) {
                    let r = 0, g = 0, b = 0, count = 0;
                    for (let dy = -radius; dy <= radius; dy++) {
                        const sy = Math.min(height - 1, Math.max(0, y + dy));
                        const idx = sy * width * 4 + colOffset;
                        r += temp[idx];
                        g += temp[idx + 1];
                        b += temp[idx + 2];
                        count++;
                    }
                    const dstIdx = y * width * 4 + colOffset;
                    pixels[dstIdx] = r / count;
                    pixels[dstIdx + 1] = g / count;
                    pixels[dstIdx + 2] = b / count;
                    pixels[dstIdx + 3] = temp[dstIdx + 3];
                }
            }
        }

        bloomCtx.putImageData(blurData, 0, 0);

        // Enhanced blend with multiple layers
        sceneCtx.globalCompositeOperation = 'screen';

        // Outer bloom layer
        sceneCtx.globalAlpha = intensity * 0.3;
        sceneCtx.drawImage(bloomCanvas, 0, 0);

        // Inner bloom layer with slight offset for depth
        sceneCtx.globalAlpha = intensity * 0.2;
        sceneCtx.drawImage(bloomCanvas, 0, 0);

        sceneCtx.globalAlpha = 1;
        sceneCtx.globalCompositeOperation = 'source-over';
    },

    applyChromaticAberration() {
        const baseOffset = state.chromaticAberration * 8;
        const audioBoost = 1 + state.bassAvg / 255 * 0.6;
        const offset = baseOffset * audioBoost;

        // Enhanced chromatic aberration with better color separation
        sceneCtx.save();

        // Red channel (shifted left)
        sceneCtx.globalCompositeOperation = 'screen';
        sceneCtx.globalAlpha = 0.35;
        sceneCtx.filter = 'brightness(1.1) contrast(1.05)';
        sceneCtx.drawImage(postProcessCanvas, -offset * 1.2, 0);

        // Green channel (center, slightly enhanced)
        sceneCtx.globalAlpha = 0.36;
        sceneCtx.filter = 'brightness(1.05)';
        sceneCtx.drawImage(postProcessCanvas, 0, 0);

        // Blue channel (shifted right)
        sceneCtx.globalAlpha = 0.35;
        sceneCtx.filter = 'brightness(1.1) contrast(1.05)';
        sceneCtx.drawImage(postProcessCanvas, offset * 1.2, 0);

        // Add subtle vertical offset for more dynamic effect
        sceneCtx.globalAlpha = 0.1;
        sceneCtx.drawImage(postProcessCanvas, -offset * 0.5, -offset * 0.3);
        sceneCtx.drawImage(postProcessCanvas, offset * 0.5, offset * 0.3);

        sceneCtx.restore();
        sceneCtx.globalAlpha = 1;
        sceneCtx.globalCompositeOperation = 'source-over';
    },

    applyVolumetricFog() {
        const fogGrad = sceneCtx.createLinearGradient(0, 0, 0, CONFIG.SCENE_HEIGHT);
        const fogColor = `rgba(${25 + state.midAvg / 10}, ${15 + state.bassAvg / 15}, ${35 + state.highAvg / 10}, ${state.fogDensity * (1 + state.bassAvg / 255 * 0.3)})`;
        fogGrad.addColorStop(0, 'transparent');
        fogGrad.addColorStop(0.5, fogColor);
        fogGrad.addColorStop(1, fogColor);

        sceneCtx.fillStyle = fogGrad;
        sceneCtx.fillRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
    },

    renderSky() {
        const grad = sceneCtx.createLinearGradient(0, 0, 0, 250);
        const bassBoost = state.bassAvg / 255 * 0.15 * state.reactivity;
        grad.addColorStop(0, `rgb(${10 + bassBoost * 50}, 5, ${15 + state.highAvg / 255 * 10})`);
        grad.addColorStop(1, `rgb(${25 + state.midAvg / 255 * 20}, 8, 35)`);
        sceneCtx.fillStyle = grad;
        sceneCtx.fillRect(0, 0, CONFIG.SCENE_WIDTH, 250);

        // Stars
        sceneCtx.fillStyle = '#fff';
        for (let i = 0; i < 60; i++) {
            const twinkle = (Math.sin(state.t * 0.03 + i * 0.5) + 1) / 2;
            const audioTwinkle = 1 + (state.highAvg / 255) * 0.5 * state.reactivity;
            sceneCtx.globalAlpha = twinkle * 0.7 * audioTwinkle;
            sceneCtx.fillRect((i * 97) % CONFIG.SCENE_WIDTH, (i * 43) % 200, 1.5, 1.5);
        }
        sceneCtx.globalAlpha = 1;

        // Clouds (simplified)
        sceneCtx.fillStyle = 'rgba(40, 20, 50, 0.12)';
        for (let i = 0; i < 4; i++) {
            const cx = ((state.t * 0.2 + i * 200) % (CONFIG.SCENE_WIDTH + 200)) - 100;
            sceneCtx.beginPath();
            sceneCtx.ellipse(cx, 80 + i * 30, 80, 25, 0, 0, Math.PI * 2);
            sceneCtx.fill();
        }
    },

    renderBuildings() {
        entities.buildings.forEach((b, bi) => {
            const pulse = 1 + Math.sin(state.t * 0.02 + b.pulsePhase) * 0.02 * (state.bassAvg / 255);
            const h = b.h * pulse;
            const y = CONFIG.SCENE_HEIGHT - h;

            const gradient = sceneCtx.createLinearGradient(b.x, y, b.x + b.w, y);
            gradient.addColorStop(0, `rgb(${25 + bi * 2}, ${20 + bi * 2}, ${35 + bi * 2})`);
            gradient.addColorStop(1, `rgb(${35 + bi * 2}, ${30 + bi * 2}, ${45 + bi * 2})`);
            sceneCtx.fillStyle = gradient;
            sceneCtx.fillRect(b.x, y, b.w, h);

            // Windows (simplified render)
            b.windows.forEach(w => {
                if (!w.lit) return;
                const brightness = w.flicker && Math.random() < 0.1 ? 0.3 : 0.8;
                const audioBoost = 1 + (state.midAvg / 255) * 0.5 * state.reactivity;
                sceneCtx.fillStyle = `hsla(${w.hue}, 80%, ${50 * brightness * audioBoost}%, ${0.7 + state.midAvg / 255 * 0.3})`;
                sceneCtx.fillRect(w.x, w.y + (CONFIG.SCENE_HEIGHT - h - b.baseY), 8, 10);
            });

            // Enhanced neon signs with multi-layer glow
            if (b.sign) {
                const signY = y + b.sign.y;
                const flicker = Math.sin(state.t * 0.3 + bi) > -0.9 ? 1 : 0.3;
                const audioGlow = 1 + (state.highAvg / 255) * 0.8 * state.reactivity;
                const baseGlow = 20 * flicker * audioGlow * state.glowAmount;

                sceneCtx.font = 'bold 18px sans-serif';

                // Outer glow layer
                sceneCtx.shadowColor = b.sign.color;
                sceneCtx.shadowBlur = baseGlow * 2;
                sceneCtx.fillStyle = b.sign.color;
                sceneCtx.fillText(b.sign.text, b.x + 5, signY);

                // Middle glow layer
                sceneCtx.shadowBlur = baseGlow * 1.5;
                sceneCtx.fillText(b.sign.text, b.x + 5, signY);

                // Inner glow layer
                sceneCtx.shadowBlur = baseGlow;
                sceneCtx.fillText(b.sign.text, b.x + 5, signY);

                // Core text
                sceneCtx.shadowBlur = 0;
                sceneCtx.fillStyle = '#ffffff';
                sceneCtx.globalAlpha = 0.9;
                sceneCtx.fillText(b.sign.text, b.x + 5, signY);
                sceneCtx.globalAlpha = 1;

                // Pulsing effect on beat
                if (state.beatDetected) {
                    sceneCtx.shadowColor = b.sign.color;
                    sceneCtx.shadowBlur = baseGlow * 2.5;
                    sceneCtx.fillStyle = b.sign.color;
                    sceneCtx.fillText(b.sign.text, b.x + 5, signY);
                }
                sceneCtx.shadowBlur = 0;
            }
        });
    },

    renderGround() {
        // Road
        sceneCtx.fillStyle = '#151515';
        sceneCtx.fillRect(0, 360, CONFIG.SCENE_WIDTH, 90);

        // Enhanced wet road reflection with screen space reflections
        const reflectionGrad = sceneCtx.createLinearGradient(0, 360, 0, 450);
        const reflectionIntensity = 0.2 + (state.midAvg / 255) * 0.15 * state.reactivity;
        reflectionGrad.addColorStop(0, `rgba(0, 80, 120, ${0.25 * reflectionIntensity})`);
        reflectionGrad.addColorStop(0.5, `rgba(0, 50, 80, ${0.15 * reflectionIntensity})`);
        reflectionGrad.addColorStop(1, 'rgba(0, 20, 40, 0.05)');
        sceneCtx.fillStyle = reflectionGrad;
        sceneCtx.fillRect(0, 360, CONFIG.SCENE_WIDTH, 90);

        // Add reflection of neon signs
        if (state.rainIntensity > 0.3) {
            sceneCtx.save();
            sceneCtx.globalCompositeOperation = 'screen';
            sceneCtx.globalAlpha = 0.3 * reflectionIntensity;
            sceneCtx.scale(1, -1);
            sceneCtx.translate(0, -CONFIG.SCENE_HEIGHT * 2);

            // Reflect neon signs
            entities.buildings.forEach((b, bi) => {
                if (b.sign) {
                    const signY = CONFIG.SCENE_HEIGHT - b.h + b.sign.y;
                    const flicker = Math.sin(state.t * 0.3 + bi) > -0.9 ? 1 : 0.3;
                    const audioGlow = 1 + (state.highAvg / 255) * 0.5 * state.reactivity;

                    sceneCtx.font = 'bold 16px sans-serif';
                    sceneCtx.fillStyle = b.sign.color;
                    sceneCtx.shadowColor = b.sign.color;
                    sceneCtx.shadowBlur = 10 * flicker * audioGlow * state.glowAmount;
                    sceneCtx.fillText(b.sign.text, b.x + 5, signY);
                }
            });

            sceneCtx.restore();
        }

        // Lane markings
        sceneCtx.strokeStyle = `rgba(255, 200, 0, ${0.5 + state.bassAvg / 255 * 0.5 * state.reactivity})`;
        sceneCtx.lineWidth = 2;
        sceneCtx.setLineDash([25, 15]);
        [385, 405, 425].forEach(y => {
            sceneCtx.beginPath();
            sceneCtx.moveTo(0, y);
            sceneCtx.lineTo(CONFIG.SCENE_WIDTH, y);
            sceneCtx.stroke();
        });
        sceneCtx.setLineDash([]);

        // Sidewalk
        sceneCtx.fillStyle = '#252525';
        sceneCtx.fillRect(0, 315, CONFIG.SCENE_WIDTH, 45);
        sceneCtx.fillStyle = '#333';
        sceneCtx.fillRect(0, 358, CONFIG.SCENE_WIDTH, 4);

        // Crosswalk
        sceneCtx.fillStyle = `rgba(255, 255, 255, ${0.7 + state.bassAvg / 255 * 0.3})`;
        for (let i = 0; i < 8; i++) {
            sceneCtx.fillRect(380 + i * 10, 360, 6, 40);
        }

        // Enhanced streetlights with volumetric lighting
        const lightPositions = [80, 200, 350, 500, 650, 750];
        lightPositions.forEach((lx, i) => {
            // Pole
            sceneCtx.fillStyle = '#333';
            sceneCtx.fillRect(lx - 2, 280, 4, 80);
            sceneCtx.fillRect(lx - 2, 280, 20, 3);

            const flicker = Math.sin(state.t * 0.1 + i * 2) > -0.95 ? 1 : 0.5;
            const audioBoost = 1 + (state.midAvg / 255) * 0.4 * state.reactivity;
            const glowSize = 25 * flicker * state.glowAmount * audioBoost;

            // Volumetric light cone
            const lightGrad = sceneCtx.createRadialGradient(lx + 15, 282, 0, lx + 15, 282, glowSize * 2);
            lightGrad.addColorStop(0, `rgba(255, 200, 100, ${0.6 * flicker * audioBoost})`);
            lightGrad.addColorStop(0.5, `rgba(255, 200, 100, ${0.3 * flicker * audioBoost})`);
            lightGrad.addColorStop(1, 'transparent');
            sceneCtx.fillStyle = lightGrad;
            sceneCtx.beginPath();
            sceneCtx.arc(lx + 15, 282, glowSize * 2, 0, Math.PI * 2);
            sceneCtx.fill();

            // Light bulb
            sceneCtx.fillStyle = `rgba(255, 220, 120, ${0.95 * flicker * audioBoost})`;
            sceneCtx.shadowColor = '#ffcc66';
            sceneCtx.shadowBlur = glowSize;
            sceneCtx.beginPath();
            sceneCtx.arc(lx + 15, 282, 6, 0, Math.PI * 2);
            sceneCtx.fill();

            // Core
            sceneCtx.shadowBlur = 0;
            sceneCtx.fillStyle = '#ffffcc';
            sceneCtx.beginPath();
            sceneCtx.arc(lx + 15, 282, 3, 0, Math.PI * 2);
            sceneCtx.fill();
        });
    },

    renderCars() {
        const sorted = [...entities.cars].sort((a, b) => a.y - b.y);

        sorted.forEach(car => {
            // Shadow
            sceneCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            sceneCtx.fillRect(car.x, car.y + car.h + 2, car.w, 5);

            // Body
            sceneCtx.fillStyle = car.color;
            sceneCtx.fillRect(car.x, car.y, car.w, car.h);
            sceneCtx.fillRect(car.x + car.w * 0.2, car.y - car.h * 0.4, car.w * 0.5, car.h * 0.4);

            // Windows
            sceneCtx.fillStyle = 'rgba(100, 150, 200, 0.3)';
            sceneCtx.fillRect(car.x + car.w * 0.22, car.y - car.h * 0.35, car.w * 0.2, car.h * 0.35);
            sceneCtx.fillRect(car.x + car.w * 0.45, car.y - car.h * 0.35, car.w * 0.2, car.h * 0.35);

            // Headlights
            const headlightX = car.dir > 0 ? car.x + car.w - 5 : car.x + 5;
            sceneCtx.fillStyle = 'rgba(255, 255, 200, 0.9)';
            sceneCtx.beginPath();
            sceneCtx.arc(headlightX, car.y + car.h * 0.3, 3, 0, Math.PI * 2);
            sceneCtx.arc(headlightX, car.y + car.h * 0.7, 3, 0, Math.PI * 2);
            sceneCtx.fill();

            // Taillights
            const tailX = car.dir > 0 ? car.x + 3 : car.x + car.w - 8;
            const tailBright = car.braking ? 1 : 0.6;
            sceneCtx.fillStyle = `rgba(255, 0, 0, ${tailBright})`;
            sceneCtx.fillRect(tailX, car.y + 3, 5, 5);
            sceneCtx.fillRect(tailX, car.y + car.h - 8, 5, 5);

            // Wheels
            sceneCtx.fillStyle = '#0a0a0a';
            sceneCtx.beginPath();
            sceneCtx.arc(car.x + 12, car.y + car.h, 6, 0, Math.PI * 2);
            sceneCtx.arc(car.x + car.w - 12, car.y + car.h, 6, 0, Math.PI * 2);
            sceneCtx.fill();
        });
    },

    renderPeople() {
        entities.people.forEach(p => {
            const bounce = Math.sin(state.t * 0.15 + p.phase) * 4 * (state.bassAvg / 255) * state.reactivity;
            const sway = p.behavior === 'dance' ? Math.sin(state.t * 0.1 + p.phase) * 3 : 0;

            const x = p.x + sway;
            const y = p.y + bounce;
            const h = p.height;

            // Shadow
            sceneCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            sceneCtx.beginPath();
            sceneCtx.ellipse(x, p.y + 5, 8, 3, 0, 0, Math.PI * 2);
            sceneCtx.fill();

            // Body
            sceneCtx.fillStyle = p.clothesColor;
            sceneCtx.fillRect(x - 5, y - h * 0.6, 10, h * 0.4);

            // Head
            sceneCtx.fillStyle = '#ddb892';
            sceneCtx.beginPath();
            sceneCtx.arc(x, y - h * 0.75, 6, 0, Math.PI * 2);
            sceneCtx.fill();

            // Hair
            sceneCtx.fillStyle = p.hairColor;
            sceneCtx.beginPath();
            sceneCtx.arc(x, y - h * 0.8, 6, Math.PI, Math.PI * 2);
            sceneCtx.fill();

            // Umbrella
            if (p.umbrella) {
                sceneCtx.fillStyle = p.umbrellaColor;
                sceneCtx.beginPath();
                sceneCtx.arc(x, y - h - 15, 18, Math.PI, Math.PI * 2);
                sceneCtx.fill();
            }
        });
    },

    renderRain() {
        if (state.rainIntensity <= 0) return;

        sceneCtx.strokeStyle = `rgba(150, 180, 220, ${0.3 * state.rainIntensity})`;
        sceneCtx.lineWidth = 1;

        entities.raindrops.forEach(drop => {
            sceneCtx.beginPath();
            sceneCtx.moveTo(drop.x, drop.y);
            sceneCtx.lineTo(drop.x + 3, drop.y + drop.length);
            sceneCtx.stroke();
        });

        // Splashes
        sceneCtx.strokeStyle = 'rgba(150, 180, 220, 0.5)';
        entities.splashes.forEach(s => {
            sceneCtx.globalAlpha = s.alpha;
            sceneCtx.beginPath();
            sceneCtx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
            sceneCtx.stroke();
        });
        sceneCtx.globalAlpha = 1;
    },

    renderParticles() {
        // Enhanced steam with glow
        entities.steamParticles.forEach(p => {
            const glow = 1 + (state.midAvg / 255) * 0.5 * state.reactivity;

            // Outer glow
            const gradient = sceneCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 1.5);
            gradient.addColorStop(0, `rgba(200, 220, 255, ${p.alpha * 0.6 * glow})`);
            gradient.addColorStop(0.5, `rgba(180, 200, 220, ${p.alpha * 0.4 * glow})`);
            gradient.addColorStop(1, 'transparent');
            sceneCtx.fillStyle = gradient;
            sceneCtx.beginPath();
            sceneCtx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI * 2);
            sceneCtx.fill();

            // Core
            sceneCtx.fillStyle = `rgba(220, 240, 255, ${p.alpha * glow})`;
            sceneCtx.beginPath();
            sceneCtx.arc(p.x, p.y, p.size * 0.6, 0, Math.PI * 2);
            sceneCtx.fill();
        });

        // Enhanced sparks with trails
        entities.sparks.forEach(s => {
            const sparkGlow = s.life * (1 + state.bassAvg / 255 * 0.8);

            // Trail
            if (s.prevX !== undefined && s.prevY !== undefined) {
                const gradient = sceneCtx.createLinearGradient(s.prevX, s.prevY, s.x, s.y);
                gradient.addColorStop(0, `rgba(255, 255, 100, ${sparkGlow * 0.3})`);
                gradient.addColorStop(1, `rgba(255, 255, 100, ${sparkGlow * 0.8})`);
                sceneCtx.strokeStyle = gradient;
                sceneCtx.lineWidth = 2;
                sceneCtx.shadowColor = '#ffff00';
                sceneCtx.shadowBlur = 4;
                sceneCtx.beginPath();
                sceneCtx.moveTo(s.prevX, s.prevY);
                sceneCtx.lineTo(s.x, s.y);
                sceneCtx.stroke();
            }

            // Spark core
            sceneCtx.fillStyle = `rgba(255, 255, 150, ${sparkGlow})`;
            sceneCtx.shadowColor = '#ffff00';
            sceneCtx.shadowBlur = 8 * sparkGlow;
            sceneCtx.beginPath();
            sceneCtx.arc(s.x, s.y, 2 * sparkGlow, 0, Math.PI * 2);
            sceneCtx.fill();

            // Store position for next frame
            s.prevX = s.x;
            s.prevY = s.y;
        });
        sceneCtx.shadowBlur = 0;
    }
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LED RENDERING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const led = {
  render() {
    if (useWebGL && gl && glProgram) {
      this.renderWebGL();
    } else {
      this.render2D();
    }
  },

  renderWebGL() {
    const w = ledCanvas.width;
    const h = ledCanvas.height;

    gl.viewport(0, 0, w, h);
    gl.useProgram(glProgram);

    // Upload scene texture
    gl.bindTexture(gl.TEXTURE_2D, glTextures.scene);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sceneCanvas);

    // Upload frequency data as texture
    const freqTex = new Uint8Array(256 * 4);
    for (let i = 0; i < 256; i++) {
      const val = freqData[i] || 0;
      freqTex[i * 4] = val;
      freqTex[i * 4 + 1] = val;
      freqTex[i * 4 + 2] = val;
      freqTex[i * 4 + 3] = 255;
    }
    gl.bindTexture(gl.TEXTURE_2D, glTextures.freq);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, freqTex);

    // Set uniforms with enhanced parameters
    const glowLoc = gl.getUniformLocation(glProgram, "u_glow");
    const reactLoc = gl.getUniformLocation(glProgram, "u_reactivity");
    const timeLoc = gl.getUniformLocation(glProgram, "u_time");
    gl.uniform1f(glowLoc, state.glowAmount);
    gl.uniform1f(reactLoc, state.reactivity);
    if (timeLoc) {
      gl.uniform1f(timeLoc, state.t * 0.01);
    }

    render2D() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const w = ledCanvas.width / dpr;
        const h = ledCanvas.height / dpr;

        // Enhanced background with subtle gradient
        const bgGrad = ledCtx.createLinearGradient(0, 0, 0, h);
        bgGrad.addColorStop(0, '#000000');
        bgGrad.addColorStop(1, '#050508');
        ledCtx.fillStyle = bgGrad;
        ledCtx.fillRect(0, 0, w, h);

        const cols = state.pixelSize;
        const rows = Math.floor(cols * (h / w) * (CONFIG.SCENE_HEIGHT / CONFIG.SCENE_WIDTH));
        const ledW = w / cols;
        const ledH = h / rows;
        const gap = Math.max(0.5, ledW * 0.12);

        // Use better sampling with bilinear interpolation simulation
        const sceneData = sceneCtx.getImageData(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT).data;
        const scaleX = CONFIG.SCENE_WIDTH / cols;
        const scaleY = CONFIG.SCENE_HEIGHT / rows;

        // Define getPixel function once outside the loop
        const getPixel = (x, y) => {
            const idx = (y * CONFIG.SCENE_WIDTH + x) * 4;
            return {
                r: sceneData[idx] || 0,
                g: sceneData[idx + 1] || 0,
                b: sceneData[idx + 2] || 0
            };
        };

        // Pre-calculate audio boost values for performance
        const audioBoosts = new Array(cols);
        for (let col = 0; col < cols; col++) {
            const freqIdx = Math.floor((col / cols) * 64);
            const freqVal = freqData[freqIdx] || 0;
            audioBoosts[col] = 1 + (freqVal / 255) * state.reactivity * 0.8;
        }

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Enhanced sampling with bilinear interpolation
                const fx = col * scaleX;
                const fy = row * scaleY;
                const x1 = Math.floor(fx);
                const y1 = Math.floor(fy);
                const x2 = Math.min(CONFIG.SCENE_WIDTH - 1, x1 + 1);
                const y2 = Math.min(CONFIG.SCENE_HEIGHT - 1, y1 + 1);

                const fracX = fx - x1;
                const fracY = fy - y1;

                // Sample 4 pixels for bilinear interpolation
                const p11 = getPixel(x1, y1);
                const p21 = getPixel(x2, y1);
                const p12 = getPixel(x1, y2);
                const p22 = getPixel(x2, y2);

                // Bilinear interpolation
                let r = p11.r * (1 - fracX) * (1 - fracY) +
                       p21.r * fracX * (1 - fracY) +
                       p12.r * (1 - fracX) * fracY +
                       p22.r * fracX * fracY;
                let g = p11.g * (1 - fracX) * (1 - fracY) +
                       p21.g * fracX * (1 - fracY) +
                       p12.g * (1 - fracX) * fracY +
                       p22.g * fracX * fracY;
                let b = p11.b * (1 - fracX) * (1 - fracY) +
                       p21.b * fracX * (1 - fracY) +
                       p12.b * (1 - fracX) * fracY +
                       p22.b * fracX * fracY;

                // Enhanced audio boost with smooth curve
                const boost = audioBoosts[col];
                const boostSmooth = Math.pow(boost, 1.2); // Smooth curve

                r = Math.min(255, r * boostSmooth);
                g = Math.min(255, g * boostSmooth);
                b = Math.min(255, b * boostSmooth);

                const x = col * ledW + gap / 2;
                const y = row * ledH + gap / 2;
                const lw = ledW - gap;
                const lh = ledH - gap;

                // Calculate brightness once
                const brightness = (r + g + b) / 3;

                // Use canvas shadow for glow effect (GPU-accelerated, much faster than gradients)
                if (state.glowAmount > 0 && brightness > 100) {
                    const glowIntensity = (brightness / 255) * state.glowAmount;
                    ledCtx.shadowBlur = lw * 0.8 * glowIntensity;
                    ledCtx.shadowColor = `rgb(${r}, ${g}, ${b})`;
                } else {
                    ledCtx.shadowBlur = 0;
                }

                // LED pixel with enhanced rendering
                ledCtx.fillStyle = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                utils.drawRoundedRect(ledCtx, x, y, lw, lh, lw * 0.15);
                ledCtx.fill();

                // Reset shadow for highlight
                ledCtx.shadowBlur = 0;

                // Enhanced highlight using simple alpha blending
                if (brightness > 80) {
                    ledCtx.fillStyle = `rgba(255, 255, 255, ${0.2 * (brightness / 255)})`;
                    utils.drawRoundedRect(ledCtx, x, y, lw, lh * 0.4, lw * 0.15);
                    ledCtx.fill();
                    ledCtx.globalAlpha = 1.0;
                }
            }
        }

        // LED pixel with enhanced rendering
        ledCtx.fillStyle = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
        utils.drawRoundedRect(ledCtx, x, y, lw, lh, lw * 0.15);
        ledCtx.fill();

        // Enhanced highlight with gradient
        if (brightness > 80) {
          const highlightGrad = ledCtx.createLinearGradient(x, y, x, y + lh * 0.4);
          highlightGrad.addColorStop(0, `rgba(255, 255, 255, ${0.2 * (brightness / 255)})`);
          highlightGrad.addColorStop(1, "transparent");
          ledCtx.fillStyle = highlightGrad;
          utils.drawRoundedRect(ledCtx, x, y, lw, lh * 0.4, lw * 0.15);
          ledCtx.fill();
        }
      }
    }

    this.applyPostProcessing(w, h);
  },

  renderLEDGrid() {
    const w = ledCanvas.width / window.devicePixelRatio;
    const h = ledCanvas.height / window.devicePixelRatio;
    const cols = state.pixelSize;
    const rows = Math.floor(cols * (h / w) * (CONFIG.SCENE_HEIGHT / CONFIG.SCENE_WIDTH));
    const ledW = w / cols;
    const ledH = h / rows;
    const gap = Math.max(0.5, ledW * 0.12);

    ledCtx.strokeStyle = "rgba(0, 255, 255, 0.1)";
    ledCtx.lineWidth = 0.5;
    for (let row = 0; row <= rows; row++) {
      ledCtx.beginPath();
      ledCtx.moveTo(0, row * ledH);
      ledCtx.lineTo(w, row * ledH);
      ledCtx.stroke();
    }
    for (let col = 0; col <= cols; col++) {
      ledCtx.beginPath();
      ledCtx.moveTo(col * ledW, 0);
      ledCtx.lineTo(col * ledW, h);
      ledCtx.stroke();
    }
  },

  applyPostProcessing(w, h) {
    // Enhanced scanlines with audio reactivity
    const scanlineIntensity = 0.02 + (state.midAvg / 255) * 0.02 * state.reactivity;
    ledCtx.fillStyle = `rgba(0, 0, 0, ${scanlineIntensity})`;
    for (let y = 0; y < h; y += 3) {
      ledCtx.fillRect(0, y, w, 1);
    }

    // Enhanced vignette with smooth falloff
    const vignetteGrad = ledCtx.createRadialGradient(
      w / 2,
      h / 2,
      h * 0.25,
      w / 2,
      h / 2,
      h * 0.85
    );
    vignetteGrad.addColorStop(0, "transparent");
    vignetteGrad.addColorStop(0.7, "rgba(0, 0, 0, 0.2)");
    vignetteGrad.addColorStop(1, "rgba(0, 0, 0, 0.5)");
    ledCtx.fillStyle = vignetteGrad;
    ledCtx.fillRect(0, 0, w, h);

    // Subtle chromatic aberration on edges
    if (state.chromaticAberration > 0) {
      const caIntensity = state.chromaticAberration * 2;
      ledCtx.globalCompositeOperation = "screen";
      ledCtx.globalAlpha = 0.15;

      // Red channel shift
      ledCtx.drawImage(ledCanvas, -caIntensity, 0);
      // Blue channel shift
      ledCtx.drawImage(ledCanvas, caIntensity, 0);

      ledCtx.globalAlpha = 1;
      ledCtx.globalCompositeOperation = "source-over";
    }

    // Subtle film grain for added texture
    if (state.glowAmount > 0.3) {
      ledCtx.fillStyle = "rgba(255, 255, 255, 0.01)";
      for (let i = 0; i < 200; i++) {
        const x = Math.random() * w;
        const y = Math.random() * h;
        ledCtx.fillRect(x, y, 1, 1);
      }
    }
  },
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UI & INTERACTION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const ui = {
  initFreqBars() {
    const container = document.getElementById("freqBars");
    for (let i = 0; i < 12; i++) {
      const bar = document.createElement("div");
      bar.className = "freq-bar";
      bar.style.height = "2px";
      container.appendChild(bar);
    }

    const spectrumContainer = document.getElementById("spectrumViz");
    for (let i = 0; i < 32; i++) {
      const bar = document.createElement("div");
      bar.className = "spectrum-bar";
      bar.style.height = "2px";
      spectrumContainer.appendChild(bar);
    }
  },

  openAudioPanel(imgObj) {
    state.selectedImage = imgObj;
    const panel = document.getElementById("audioPanel");
    panel.classList.add("active");

    document.getElementById("imagePreview").src = imgObj.img.src;

    document.querySelectorAll(".band-btn").forEach((btn) => {
      btn.classList.toggle("active", btn.dataset.band === imgObj.audioMapping.band);
    });

    document.getElementById("targetScale").checked = imgObj.audioMapping.targets.scale;
    document.getElementById("targetRotation").checked = imgObj.audioMapping.targets.rotation;
    document.getElementById("targetX").checked = imgObj.audioMapping.targets.x;
    document.getElementById("targetY").checked = imgObj.audioMapping.targets.y;
    document.getElementById("targetAlpha").checked = imgObj.audioMapping.targets.alpha;
    document.getElementById("targetHue").checked = imgObj.audioMapping.targets.hue;

    document.getElementById("sensitivitySlider").value = imgObj.audioMapping.sensitivity * 100;
    document.getElementById("sensitivityValue").textContent =
      Math.round(imgObj.audioMapping.sensitivity * 100) + "%";

    document.querySelectorAll(".curve-btn").forEach((btn) => {
      btn.classList.toggle("active", btn.dataset.curve === imgObj.audioMapping.curve);
    });

    document.getElementById("smoothingSlider").value = imgObj.audioMapping.smoothing * 100;
    document.getElementById("smoothingValue").textContent =
      imgObj.audioMapping.smoothing.toFixed(1);
  },

  closeAudioPanel() {
    state.selectedImage = null;
    document.getElementById("audioPanel").classList.remove("active");
  },

  setupEventListeners() {
    // File input handlers
    document.getElementById("audioFile").addEventListener("change", (e) => {
      if (e.target.files[0]) {
        audio.setup(e.target.files[0]).catch((err) => {
          alert("Failed to load audio: " + err.message);
        });
      }
      e.target.value = ""; // Reset input
    });

    document.getElementById("imageFile").addEventListener("change", (e) => {
      if (e.target.files.length > 0) {
        const files = Array.from(e.target.files);
        files.forEach((file) => {
          if (file.type.startsWith("image/")) {
            images.load(file).catch((err) => {
              console.error("Failed to load image:", err);
            });
          }
        });
      }
      e.target.value = ""; // Reset input
    });

    // Drag and drop
    const dropZone = document.getElementById("dropZone");
    const ledFrame = document.querySelector(".led-frame");

    const preventDefaults = (e) => {
      e.preventDefault();
      e.stopPropagation();
    };

    ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
      ledFrame.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    ledFrame.addEventListener("dragenter", (e) => {
      const files = e.dataTransfer.items;
      if (files.length > 0) {
        const firstFile = files[0];
        if (firstFile.type.startsWith("audio/")) {
          dropZone.classList.add("audio-zone");
        } else {
          dropZone.classList.remove("audio-zone");
        }
        dropZone.classList.add("active");
      }
    });

    ledFrame.addEventListener("dragover", (e) => {
      preventDefaults(e);
    });

    ledFrame.addEventListener("dragleave", (e) => {
      if (!ledFrame.contains(e.relatedTarget)) {
        dropZone.classList.remove("active");
      }
    });

    ledFrame.addEventListener("drop", (e) => {
      preventDefaults(e);
      dropZone.classList.remove("active");
      const files = Array.from(e.dataTransfer.files);

      files.forEach((file) => {
        if (file.type.startsWith("audio/")) {
          audio.setup(file).catch((err) => {
            alert("Failed to load audio: " + err.message);
          });
        } else if (file.type.startsWith("image/")) {
          images.load(file).catch((err) => {
            console.error("Failed to load image:", err);
          });
        }
      });
    });

    document.getElementById("clearImagesBtn").addEventListener("click", () => {
      entities.images.length = 0;
      state.loadedFiles = state.loadedFiles.filter((f) => f.type !== "image");
      images.updateGallery();
      utils.updateStatus();
    });

    document.getElementById("playBtn").addEventListener("click", () => audio.togglePlay());

    document.getElementById("pixelSlider").addEventListener("input", (e) => {
      state.pixelSize = parseInt(e.target.value);
      document.getElementById("pixelValue").textContent = state.pixelSize;
    });

    document.getElementById("reactSlider").addEventListener("input", (e) => {
      state.reactivity = e.target.value / 100;
      document.getElementById("reactValue").textContent = `${e.target.value}%`;
    });

    document.getElementById("rainSlider").addEventListener("input", (e) => {
      state.rainIntensity = e.target.value / 100;
      document.getElementById("rainValue").textContent = `${e.target.value}%`;
    });

    document.getElementById("glowSlider").addEventListener("input", (e) => {
      state.glowAmount = e.target.value / 100;
      document.getElementById("glowValue").textContent = `${e.target.value}%`;
    });

    document.getElementById("moveMode").addEventListener("change", (e) => {
      state.imageMoveMode = e.target.value;
    });

    document.getElementById("displayMode").addEventListener("change", (e) => {
      state.imageDisplayMode = e.target.value;
    });

    document.getElementById("imageLayer").addEventListener("change", (e) => {
      state.imageLayer = e.target.value;
    });

    document.getElementById("blendMode").addEventListener("change", (e) => {
      state.imageBlendMode = e.target.value;
      entities.images.forEach((img) => (img.blendMode = state.imageBlendMode));
    });

    document.getElementById("imageSizeSlider").addEventListener("input", (e) => {
      state.imageScale = e.target.value / 100;
      document.getElementById("imageSizeValue").textContent = `${e.target.value}%`;
    });

    // Preset controls
    document.getElementById("loadPresetBtn").addEventListener("click", () => {
      document.getElementById("presetFile").click();
    });

    document.getElementById("presetFile").addEventListener("change", (e) => {
      if (e.target.files[0]) {
        utils.loadPreset(e.target.files[0]);
      }
    });

    const savePresetBtn = document.querySelector('.btn.file-btn[style*="39ff14"]');
    savePresetBtn.addEventListener("click", (e) => {
      if (e.target === savePresetBtn || e.target.parentElement === savePresetBtn) {
        utils.savePreset();
      }
    });

    // Fullscreen
    document.getElementById("fullscreenBtn").addEventListener("click", () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch((err) => {
          console.warn("Fullscreen failed:", err);
        });
      } else {
        document.exitFullscreen();
      }
    });

    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if (e.target.tagName === "INPUT") {
        return;
      }

      switch (e.key) {
        case " ":
          e.preventDefault();
          audio.togglePlay();
          break;
        case "f":
        case "F":
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
          break;
        case "s":
        case "S":
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            utils.savePreset();
          }
          break;
        case "Escape":
          if (state.selectedImage) {
            this.closeAudioPanel();
          }
          break;
      }
    });

    // Audio panel controls
    document.getElementById("closePanel").addEventListener("click", () => this.closeAudioPanel());

    document.querySelectorAll(".band-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        if (!state.selectedImage) {
          return;
        }
        document.querySelectorAll(".band-btn").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        state.selectedImage.audioMapping.band = btn.dataset.band;
      });
    });

    document.querySelectorAll(".curve-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        if (!state.selectedImage) {
          return;
        }
        document.querySelectorAll(".curve-btn").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        state.selectedImage.audioMapping.curve = btn.dataset.curve;
      });
    });

    ["Scale", "Rotation", "X", "Y", "Alpha", "Hue"].forEach((target) => {
      document.getElementById(`target${target}`).addEventListener("change", (e) => {
        if (state.selectedImage) {
          state.selectedImage.audioMapping.targets[target.toLowerCase()] = e.target.checked;
        }
      });
    });

    document.getElementById("sensitivitySlider").addEventListener("input", (e) => {
      if (state.selectedImage) {
        state.selectedImage.audioMapping.sensitivity = e.target.value / 100;
        document.getElementById("sensitivityValue").textContent = e.target.value + "%";
      }
    });

    document.getElementById("smoothingSlider").addEventListener("input", (e) => {
      if (state.selectedImage) {
        state.selectedImage.audioMapping.smoothing = e.target.value / 100;
        document.getElementById("smoothingValue").textContent = (e.target.value / 100).toFixed(1);
      }
    });

    // Canvas interaction
    ledCanvas.addEventListener("click", (e) => {
      if (state.isDragging) {
        return;
      }

      const rect = ledCanvas.getBoundingClientRect();
      const mouseX = ((e.clientX - rect.left) / rect.width) * CONFIG.SCENE_WIDTH;
      const mouseY = ((e.clientY - rect.top) / rect.height) * CONFIG.SCENE_HEIGHT;

      for (let i = entities.images.length - 1; i >= 0; i--) {
        const img = entities.images[i];
        const dx = mouseX - img.x;
        const dy = mouseY - img.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 100) {
          this.openAudioPanel(img);
          return;
        }
      }

      this.closeAudioPanel();
    });

    // Mousemove handler for dragging - added/removed dynamically
    const handleMouseMove = (e) => {
      if (state.isDragging && state.draggedImage) {
        const rect = ledCanvas.getBoundingClientRect();
        const mouseX = ((e.clientX - rect.left) / rect.width) * CONFIG.SCENE_WIDTH;
        const mouseY = ((e.clientY - rect.top) / rect.height) * CONFIG.SCENE_HEIGHT;

        state.draggedImage.baseX = mouseX;
        state.draggedImage.baseY = mouseY;
        state.draggedImage.x = mouseX;
        state.draggedImage.y = mouseY;
      }
    };

    ledCanvas.addEventListener("mousedown", (e) => {
      const rect = ledCanvas.getBoundingClientRect();
      const mouseX = ((e.clientX - rect.left) / rect.width) * CONFIG.SCENE_WIDTH;
      const mouseY = ((e.clientY - rect.top) / rect.height) * CONFIG.SCENE_HEIGHT;

      for (let i = entities.images.length - 1; i >= 0; i--) {
        const img = entities.images[i];
        const dx = mouseX - img.x;
        const dy = mouseY - img.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 100) {
          state.draggedImage = img;
          state.isDragging = true;
          // Add mousemove listener only when dragging starts
          ledCanvas.addEventListener("mousemove", handleMouseMove);
          break;
        }
      }
    });

    ledCanvas.addEventListener("mouseup", () => {
      state.isDragging = false;
      state.draggedImage = null;
      // Remove mousemove listener when dragging stops
      ledCanvas.removeEventListener("mousemove", handleMouseMove);
    });

    window.addEventListener("resize", () => utils.resizeCanvas());
  },
        });

        // Handler for mousemove event - only attached when dragging
        const handleMouseMove = (e) => {
            if (!state.draggedImage) return;

            const rect = ledCanvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / rect.width * CONFIG.SCENE_WIDTH;
            const mouseY = (e.clientY - rect.top) / rect.height * CONFIG.SCENE_HEIGHT;

            state.draggedImage.baseX = mouseX;
            state.draggedImage.baseY = mouseY;
            state.draggedImage.x = mouseX;
            state.draggedImage.y = mouseY;
        };

        ledCanvas.addEventListener('mousedown', e => {
            const rect = ledCanvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / rect.width * CONFIG.SCENE_WIDTH;
            const mouseY = (e.clientY - rect.top) / rect.height * CONFIG.SCENE_HEIGHT;

            for (let i = entities.images.length - 1; i >= 0; i--) {
                const img = entities.images[i];
                const dx = mouseX - img.x;
                const dy = mouseY - img.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 100) {
                    state.draggedImage = img;
                    state.isDragging = true;
                    // Add mousemove listener only when dragging starts
                    ledCanvas.addEventListener('mousemove', handleMouseMove);
                    break;
                }
            }
        });

        ledCanvas.addEventListener('mousemove', e => {
            // Early return if not dragging to avoid unnecessary calculations
            if (!state.isDragging || !state.draggedImage) {
                return;
            }

            const rect = ledCanvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / rect.width * CONFIG.SCENE_WIDTH;
            const mouseY = (e.clientY - rect.top) / rect.height * CONFIG.SCENE_HEIGHT;

            state.draggedImage.baseX = mouseX;
            state.draggedImage.baseY = mouseY;
            state.draggedImage.x = mouseX;
            state.draggedImage.y = mouseY;
        });

        ledCanvas.addEventListener('mouseup', () => {
            // Always remove mousemove listener to prevent any memory leaks
            ledCanvas.removeEventListener('mousemove', handleMouseMove);
            state.isDragging = false;
            state.draggedImage = null;
        });

        window.addEventListener('resize', () => utils.resizeCanvas());
    }
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function animate() {
  try {
    audio.process();

    // Update
    images.update();
    scene.update();
    beatSpawning.update(); // Update beat-spawned objects

    // Render scene
    if (state.imageLayer === "back") {
      images.render();
    }

    if (state.imageLayer !== "only") {
      scene.render();
    }

    if (state.imageLayer === "front" || state.imageLayer === "only") {
      if (state.imageLayer === "only") {
        sceneCtx.clearRect(0, 0, CONFIG.SCENE_WIDTH, CONFIG.SCENE_HEIGHT);
      }
      images.render();

      // Render beat-spawned objects on top
      beatSpawning.render(sceneCtx);
    }

    // Render LED
    led.render();

    // Performance monitoring
    perf.update();
    if (perf.frameCount % 60 === 0) {
      utils.updateStatus();
    }

    state.t++;
    requestAnimationFrame(animate);
  } catch (err) {
    console.error("Animation error:", err);
    // Continue animation even on error
    requestAnimationFrame(animate);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INITIALIZATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Initialize with error handling
try {
  utils.resizeCanvas();
  scene.init();
  ui.initFreqBars();
  ui.setupEventListeners();

  // Initialize character control system
  if (typeof characterControl !== "undefined") {
    characterControl.init();
  }

  images.updateGallery(); // Initialize empty gallery

  // Load default preset from scene-preset-schema.json
  utils.loadDefaultPreset();

  animate();
} catch (err) {
  console.error("Initialization error:", err);
  alert("Failed to initialize. Please refresh the page.");
}
</script>
</body>
</html>
